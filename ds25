Slip1
Q1 write a c program that accepts the vertices and edges of a graph and stores it as an 
adjacency matrix . Display the adjacency matrix.
#include<stdio.h>
#include<malloc.h>
typedef struct node
{
int vertex;
struct node *next;
}NODE;
NODE *list[10];
void createmat(int m[10][10], int n)
{
int i,j;
char ans;
for(i=0;i<n;i++)
for(j=0;j<n;j++)
{
m[i][i]=0;
if(i!=j)
{
printf("Is there an edge between %d and %d (1/0) ",i+1,j+1);
scanf("%d", &m[i][j]);
}
}}
void dispmat(int m[10][10], int n)
{
int i,j;
printf("\nThe adjacency matrix is :\n");
for(i=0; i<n; i++)
{
for(j=0; j<n; j++)
printf("%5d", m[i][j]);
printf("\n");
}
}
void createlist(int m[10][10], int n)
{
int i,j;
struct node *temp, *newnode;
for(i=0; i<n; i++)
{
list[i]=NULL;
for(j=0; j<n; j++)
{
if(m[i][j]==1)
{
newnode=(NODE *)malloc(sizeof(NODE));newnode->next=NULL;
newnode->vertex=j+1;
if(list [i]==NULL)
list[i]=temp=newnode;
else
{
temp->next=newnode;
temp=newnode;
}
}
}
}
}
void displist(int n)
{
struct node *temp;
int i;
printf("\nThe adjacency list is:\n");
for(i=0; i<n; i++)
{
printf("\nv%d :", i+1);
temp=list[i];
while(temp)
{
printf("v%d ->", temp->vertex);temp=temp->next;
}
printf("NULL");
}
}
void main()
{
int m[10][10], n;
printf("\nEnter the number of vertices:");
scanf("%d", &n);
createmat(m,n);
dispmat(m,n);
createlist(m,n);
displist(n);
}
Q 2. Implement a Binary search tree (BST) library (btree.h) with operations – create, 
insert, preorder. Write a menu driven program that performs the above operations.
#include <stdio.h>
#include <stdlib.h>
typedef struct Node{
int data;
struct Node* left;
struct Node* right;
}Node;
Node* root = NULL;
Node* newNode(int d){
Node* newnode = (Node*)malloc(sizeof(Node));
newnode->data = d;
newnode->left = NULL;
newnode->right = NULL;
return newnode;
}
Node* buildBST(Node* root,int x){
if(root == NULL){
root = newNode(x);
return root;
}
else if(root->data > x){
root->left = buildBST(root->left,x);
}
else{
root->right = buildBST(root->right,x);
}
return root;
}
void solve(){
int data;
printf("Enter the data\n");
scanf("%d",&data);
while(data!=-1){
root = buildBST(root,data);
scanf("%d",&data);
}
}
int search(Node* root,int x){
if(root == NULL){
return 0;
}
else if(root->data == x){
return 1;
}
else if(root -> data > x){
return search(root->left,x);
}
else{
return search(root->right,x);
}
}
int searchBST(){
int data;
printf("Enter data to be searched\n");
scanf("%d",&data);
int ans;
ans = search(root,data);
if(ans == 1){
printf("data is present\n");
}
else{
printf("data is not present\n");
}
}
void inorder(Node* root){
if(root==NULL){
return;
}
inorder(root->left);
printf("%d ",root->data);
inorder(root->right);
}
void postorder(Node* root){
if(root==NULL){
return;
}
inorder(root->left);
inorder(root->right);
printf("%d ",root->data);
}
void preorder(Node* root){
if(root==NULL){
return;
}
printf("%d ",root->data);
inorder(root->left);
inorder(root->right);
}
int main(){
solve();
printf("\n");
printf("ROOT data = %d\n",root->data);
printf("Inorder Traversal : \n");
inorder(root);
printf("preorder Traversal : \n");
preorder(root);printf("\n");
printf("postorder Traversal : \n");
postorder(root);printf("\n");
printf("\n");
searchBST();
return 0;
}
OR
Q2. Write a C program for the Implementation of Prim’s Minimum spanning tree 
algorithm.
#include<stdio.h>
int a,b,u,v,n,i,j,ne=1;
int visited[10]= {0}
,min,mincost=0,cost[10][10];
void main() 
{
printf("\n Enter the number of nodes:");
scanf("%d",&n);
printf("Enter cost in form of adjacency matrix\n");
for (i=1;i<=n;i++)
for (j=1;j<=n;j++) {
scanf("%d",&cost[i][j]);
if(cost[i][j]==0)
cost[i][j]=999;
}
visited[1]=1;
printf("\n");
while(ne<n) 
{
for (i=1,min=999;i<=n;i++)
for (j=1;j<=n;j++)
if(cost[i][j]<min)
if(visited[i]!=0) 
{
min=cost[i][j];
a=u=i;
b=v=j;
}
if(visited[u]==0 || visited[v]==0) 
{
printf("\n Edge %d:(%d %d) cost:%d",ne++,a,b,min);
mincost+=min;
visited[b]=1;
}
cost[a][b]=cost[b][a]=999;
}
printf("\n Minimun cost=%d",mincost);
}
Slip2
Q1. Write a C program for the implementation of Topological sorting.
#include <stdio.h>
int main(){
int i,j,k,n,a[10][10],indeg[10],flag[10],count=0;
printf("Enter the no of vertices:\n");
scanf("%d",&n);
printf("Enter the adjacency matrix:\n");
for(i=0;i<n;i++){
printf("Enter row %d\n",i+1);
for(j=0;j<n;j++)
scanf("%d",&a[i][j]);
}
for(i=0;i<n;i++)
{
indeg[i]=0;
flag[i]=0;
}
for(i=0;i<n;i++)
for(j=0;j<n;j++)
indeg[i]=indeg[i]+a[j][i];
printf("\nThe topological order is:");
while(count<n)
{
for(k=0;k<n;k++){
if((indeg[k]==0) && (flag[k]==0))
{
printf("%d ",(k+1));
flag [k]=1;
}
for(i=0;i<n;i++){
if(a[i][k]==1)
indeg[k]--;
}
}
count++;
}
return 0;
}
Q2. Write a C program that accepts the vertices and edges of a graph and stores it as 
an adjacency matrix. Display the adjacency matrix.
#include<stdio.h>
#include<malloc.h>
typedef struct node
{
int vertex;
struct node *next;
}NODE;
NODE *list[10];
void createmat(int m[10][10], int n)
{
int i,j;
char ans;
for(i=0;i<n;i++)
for(j=0;j<n;j++)
{
m[i][i]=0;
if(i!=j)
{
printf("Is there an edge between %d and %d (1/0) ",i+1,j+1);
scanf("%d", &m[i][j]);
}
}}
void dispmat(int m[10][10], int n)
{
int i,j;
printf("\nThe adjacency matrix is :\n");
for(i=0; i<n; i++)
{
for(j=0; j<n; j++)
printf("%5d", m[i][j]);
printf("\n");
}
}
void createlist(int m[10][10], int n)
{
int i,j;
struct node *temp, *newnode;
for(i=0; i<n; i++)
{
list[i]=NULL;
for(j=0; j<n; j++)
{
if(m[i][j]==1)
{
newnode=(NODE *)malloc(sizeof(NODE));newnode->next=NULL;
newnode->vertex=j+1;
if(list [i]==NULL)
list[i]=temp=newnode;
else
{
temp->next=newnode;
temp=newnode;
}
}
}
}
}
void displist(int n)
{
struct node *temp;
int i;
printf("\nThe adjacency list is:\n");
for(i=0; i<n; i++)
{
printf("\nv%d :", i+1);
temp=list[i];
while(temp)
{
printf("v%d ->", temp->vertex);temp=temp->next;
}
printf("NULL");
}
}
void main()
{
int m[10][10], n;
printf("\nEnter the number of vertices:");
scanf("%d", &n);
createmat(m,n);
dispmat(m,n);
createlist(m,n);
displist(n);
}
OR
Q 2. Write a C program that accepts the vertices and edges of a graph and store it as 
an adjacency matrix. Implement function to traverse the graph using Depth First 
Search (DFS) traversal
#include<stdio.h>
#define MAX 10
typedef struct
{
int data[MAX];
int top;
}STACK;
void initstack(STACK * ps)
{
ps->top=-1;
}
void push(STACK *ps, int num)
{
ps->data[++ps->top]=num;
}
int pop(STACK *ps)
{
return(ps->data[ps->top--]);
}
int isempty(STACK *ps)
{
return(ps->top==-1);
}
int isfull(STACK *ps){
return (ps->top==MAX-1);
}
void dfs(int m[10][10], int n)
{
int i, v, w, found;
int visited[10]={0};
STACK s;
initstack(&s);
v=0;
visited[v]=1;
push(&s,v);
printf("v%d" ,v+1);
while(1)
{
found=0;
for(w=0; w<n; w++)
{
if((m[v][w]==1)&&(visited[w]==0))
{
push(&s, w);
printf("v%d", w+1);
visited[w]=1;
v = w;
found = 1;break;
}
}
if(found == 0)// did not find an adjacent unvisited vertex
if(isempty(&s))
break;
else
v = pop(&s);
}
}
int recdfs(int m[10][10], int n, int v)
{
int w;
static int visited[10]={0};
visited[v]=1;
printf("v%d" ,v+1);
for(w=0; w<n; w++)
{
if( (m[v] [w]==1) && (visited[w]==0) )
recdfs(m,n,w);
}
}
int main()
{int m[10][10], n, i, j, w;
printf("\nHow many vertices:");
scanf("%d", &n);
for(i=0; i<n; i++)
for(j=0; j<n; j++)
{
if(i!=j)
{
printf("Is there edge between vertex %d and %d(1/0):", i+1, j+1);
scanf("%d", &m[i][j]);
}
}
printf("\nNon recursive depth first search is :");
dfs(m,n);
printf("\nRecursive depth first search is :");
recdfs(m,n,0);
}
Slip3
Q 1. Write a C program for the Implementation of Prim’s Minimum spanning tree 
algorithm.
#include<stdio.h>
int a,b,u,v,n,i,j,ne=1;
int visited[10]= {0}
,min,mincost=0,cost[10][10];
void main() 
{
printf("\n Enter the number of nodes:");
scanf("%d",&n);
printf("Enter cost in form of adjacency matrix\n");
for (i=1;i<=n;i++)
for (j=1;j<=n;j++) {
scanf("%d",&cost[i][j]);
if(cost[i][j]==0)
cost[i][j]=999;
}
visited[1]=1;
printf("\n");
while(ne<n) 
{
for (i=1,min=999;i<=n;i++)
for (j=1;j<=n;j++)
if(cost[i][j]<min)
if(visited[i]!=0) 
{
min=cost[i][j];
a=u=i;
b=v=j;
}
if(visited[u]==0 || visited[v]==0) 
{
printf("\n Edge %d:(%d %d) cost:%d",ne++,a,b,min);
mincost+=min;
visited[b]=1;
}
cost[a][b]=cost[b][a]=999;
}
printf("\n Minimun cost=%d",mincost);
}
Q 2. Write a C program that accepts the vertices and edges of a graph and stores it as 
an adjacency matrix. Display the adjacency matrix.
#include<stdio.h>
#include<malloc.h>
typedef struct node
{
int vertex;
struct node *next;
}NODE;
NODE *list[10];
void createmat(int m[10][10], int n)
{
int i,j;
char ans;
for(i=0;i<n;i++)
for(j=0;j<n;j++)
{
m[i][i]=0;
if(i!=j)
{
printf("Is there an edge between %d and %d (1/0) ",i+1,j+1);
scanf("%d", &m[i][j]);
}
}}
void dispmat(int m[10][10], int n)
{
int i,j;
printf("\nThe adjacency matrix is :\n");
for(i=0; i<n; i++)
{
for(j=0; j<n; j++)
printf("%5d", m[i][j]);
printf("\n");
}
}
void createlist(int m[10][10], int n)
{
int i,j;
struct node *temp, *newnode;
for(i=0; i<n; i++)
{
list[i]=NULL;
for(j=0; j<n; j++)
{
if(m[i][j]==1)
{
newnode=(NODE *)malloc(sizeof(NODE));newnode->next=NULL;
newnode->vertex=j+1;
if(list [i]==NULL)
list[i]=temp=newnode;
else
{
temp->next=newnode;
temp=newnode;
}
}
}
}
}
void displist(int n)
{
struct node *temp;
int i;
printf("\nThe adjacency list is:\n");
for(i=0; i<n; i++)
{
printf("\nv%d :", i+1);
temp=list[i];
while(temp)
{
printf("v%d ->", temp->vertex);temp=temp->next;
}
printf("NULL");
}
}
void main()
{
int m[10][10], n;
printf("\nEnter the number of vertices:");
scanf("%d", &n);
createmat(m,n);
dispmat(m,n);
createlist(m,n);
displist(n);
}
OR
Q 2. Write a C program for the implementation of Floyd Warshall’s algorithm for finding 
all pairs shortest path using adjacency cost matrix.
#include <stdio.h>
#define V 4
#define INF 99999
void printSolution(int dist[][V]);
void floydWarshall(int dist[][V]) {
int i, j, k;
 for (k = 0; k < V; k++) {
 for (i = 0; i < V; i++) {
 for (j = 0; j < V; j++) {
 if (dist[i][k] + dist[k][j] < dist[i][j])
 dist[i][j] = dist[i][k] + dist[k][j];
 }
 }
 }
 printSolution(dist);
}
void printSolution(int dist[][V]) {
 printf("The following matrix shows the shortest distances between every pair of 
vertices:\n");
 for (int i = 0; i < V; i++) {
 for (int j = 0; j < V; j++) {
 if (dist[i][j] == INF)
 printf("%7s", "INF");
 else
 printf("%7d", dist[i][j]);
 }
 printf("\n");
 }
}
int main() {
 int graph[V][V] = { {0, 5, INF, 10},
 {INF, 0, 3, INF},
 {INF, INF, 0, 1},
 {INF, INF, INF, 0} };
 floydWarshall(graph);
 return 0;
}
Slip4
Q 1. Write a C program that accepts the vertices and edges of a graph. Create 
adjacency list.
#include<stdio.h>
#include<stdio.h>
#include<malloc.h>
typedef struct node
{
int vertex;
struct node *next;
}NODE;
NODE *list[10];
void createmat(int m[10][10], int n)
{
int i,j;
char ans;
for(i=0;i<n;i++)
for(j=0;j<n;j++)
{
m[i][i]=0;
if(i!=j)
{
printf("Is there an edge between %d and %d (1/0) ",i+1,j+1);
scanf("%d", &m[i][j]);
}
}}
void createlist(int m[10][10], int n)
{
int i,j;
struct node *temp, *newnode;
for(i=0; i<n; i++)
{
list[i]=NULL;
for(j=0; j<n; j++)
{
if(m[i][j]==1)
{
newnode=(NODE *)malloc(sizeof(NODE));newnode->next=NULL;
newnode->vertex=j+1;
if(list [i]==NULL)
list[i]=temp=newnode;
else
{
temp->next=newnode;
temp=newnode;
}
}
}
}
}
void displist(int n)
{
struct node *temp;
int i;
printf("\nThe adjacency list is:\n");
for(i=0; i<n; i++)
{
printf("\nv%d :", i+1);
temp=list[i];
while(temp)
{
printf("v%d ->", temp->vertex);temp=temp->next;
}
printf("NULL");
}
}
void main()
{
int m[10][10], n;
printf("\nEnter the number of vertices:");
scanf("%d", &n);
createmat(m,n);
createlist(m,n);
displist(n);
}
Q2. Write a C program for the implementation of Topological sorting.
#include <stdio.h>
int main(){
int i,j,k,n,a[10][10],indeg[10],flag[10],count=0;
printf("Enter the no of vertices:\n");
scanf("%d",&n);
printf("Enter the adjacency matrix:\n");
for(i=0;i<n;i++){
printf("Enter row %d\n",i+1);
for(j=0;j<n;j++)
scanf("%d",&a[i][j]);
}
for(i=0;i<n;i++)
{
indeg[i]=0;
flag[i]=0;
}
for(i=0;i<n;i++)
for(j=0;j<n;j++)
indeg[i]=indeg[i]+a[j][i];
printf("\nThe topological order is:");
while(count<n)
{
for(k=0;k<n;k++){
if((indeg[k]==0) && (flag[k]==0))
{
printf("%d ",(k+1));
flag [k]=1;
}
for(i=0;i<n;i++){
if(a[i][k]==1)
indeg[k]--;
}
}
count++;
}
return 0;
}
OR
Q 2. Write a program which uses binary search tree library and counts the total nodes 
and totalleaf nodes in the tree. int countLeaf(T) – returns the total number of leaf 
nodes from BST.
#include <stdio.h>
#include <stdlib.h>
typedef struct Node{
int data;
struct Node* left;
struct Node* right;
}Node;
Node* root = NULL;
int totalNodes = 0;
int totalleaf = 0;
Node* newNode(int d){
Node* newnode = (Node*)malloc(sizeof(Node));
newnode->data = d;
newnode->left = NULL;
newnode->right = NULL;
return newnode;
}
Node* buildBST(Node* root,int x){
if(root == NULL){
root = newNode(x);
return root;
}
else if(root->data > x){
root->left = buildBST(root->left,x);
}
else{
root->right = buildBST(root->right,x);
}
return root;
}
void solve(){
int data;
printf("Enter the data\n");
scanf("%d",&data);
while(data!=-1){
root = buildBST(root,data);
scanf("%d",&data);
}
}
void countNodes(Node* root){
if(root == NULL){
return;
}
if(root!=NULL){
totalNodes++;
}
countNodes(root->left);
countNodes(root->right);
}
void countleaf(Node* root){
if(root==NULL)
return;
if(root->left == NULL && root->right == NULL){
totalleaf++;
return;
}
countleaf(root->left);
countleaf(root->right);
}
int main(){
solve();
printf("\n");
countNodes(root);
countleaf(root);
printf("total Nodes = %d",totalNodes);
printf("Total leaf Nodes = %d",totalleaf);
return 0;
}
Slip5
Q 1. Write a C program which uses Binary search tree library and displays nodes at 
each level,count of node at each level.
#include <stdio.h>
#include <stdlib.h>
// Define the structure for a binary tree node
struct TreeNode {
 int data;
 struct TreeNode* left;
 struct TreeNode* right;
};
// Function to create a new node
struct TreeNode* createNode(int value) {
 struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
 newNode->data = value;
 newNode->left = NULL;
 newNode->right = NULL;
 return newNode;
}
// Function to insert a node into the BST
struct TreeNode* insertNode(struct TreeNode* root, int value) {
 if (root == NULL)
 return createNode(value);
 if (value < root->data)
 root->left = insertNode(root->left, value);
 else if (value > root->data)
 root->right = insertNode(root->right, value);
 return root;
}
// Function to perform level order traversal and count nodes at each level
void levelOrderTraversal(struct TreeNode* root) {
 if (root == NULL)
 return;
 // Initialize a queue for level order traversal
 struct TreeNode* queue[100];
 int front = 0, rear = 0;
 queue[rear++] = root;
 while (front < rear) {
 int levelCount = rear - front;
 printf("Level %d: ", front + 1);
 while (levelCount--) {
 struct TreeNode* current = queue[front++];
 printf("%d ", current->data);
 if (current->left)
 queue[rear++] = current->left;
 if (current->right)
 queue[rear++] = current->right;
 }
 printf("(Count: %d)\n", rear -front);
 }
}
int main() {
 struct TreeNode* root = NULL;
 root = insertNode(root, 50);
 insertNode(root, 30);
 insertNode(root, 70);
 insertNode(root, 20);
 insertNode(root, 40);
 insertNode(root, 60);
 insertNode(root, 80);
 printf("Nodes at each level:\n");
 levelOrderTraversal(root);
 return 0;
}
Q 2. Write a program to sort n randomly generated elements using Heapsort method.
#include<stdio.h>
#include<stdlib.h>
void display(int arr[],int n)
{
int i;
for(i=0; i<n; i++)
printf("%d\t", arr[i]);
}
void heapify(int a[], int top, int last)
{
int j, temp, key;
key = a[top];
j = 2*top+1;
if( (j<last) && (a[j] < a[j+1]) )
j = j+1;
if( (j<=last) && (key<a[j]) )
{
temp = a[top];
a[top] = a[j];
a[j] = temp;
heapify(a,j,last);
}
}void buildheap(int a[], int n)
{
int i;
for(i=n/2-1; i>=0; i--)
heapify(a,i,n-1);
}
void heapsort(int a[], int n)
{
int i, temp, top=0, last;
buildheap(a,n);
printf("Initial heap = ");
display(a,n);
for(last=n-1; last>=1; last--)
{
temp = a[top];
a[top] = a[last];
a[last] = temp;
printf("\n\nAfter iteration %d : ", n-last);
display(a,n);
heapify(a,top,last-1);
}
}
int main(){
int a[8] = {26,5,77,1,61,11,59,15};
heapsort(a,8);
return 0;
}
OR
Q 2. Write a C program that accepts the vertices and edges of a graph and store it as 
an adjacency matrix. Implement function to traverse the graph using Breadth First 
Search (BFS) traversal.
#include<stdio.h>
#define MAX 10
typedef struct
{
int data[MAX];
int front, rear;
}QUEUE;
/**functions****/
void initq(QUEUE *pq)
{
pq->front = pq->rear = -1;
}
void addq(QUEUE *pq, int num)
{
pq->rear++;
pq->data[pq->rear] = num;
}
int removeq(QUEUE *pq)
{
int num;
pq->front++;
num=pq->data[pq->front];
return(num);
}int isempty(QUEUE *pq)
{
return(pq->front == pq->rear);
}
int isfull(QUEUE *pq)
{
return(pq->rear==MAX-1);
}
void bfs(int m[10][10], int n)
{
int i, v, w;
int visited[10]={0};
QUEUE q;
initq(&q);
v=0;
visited[v]=1;
addq(&q,v);
while(!isempty(&q))
{
v=removeq(&q);
printf("v%d",v+1);
for(w=0; w<n; w++)
{
if((m[v][w]==1)&&(visited[w]==0)){
addq(&q, w);
visited[w]=1;
}
}
}
}
int main()
{
int m[10][10], n, i, j, w;
printf("\nHow many vertices:");
scanf("%d", &n);
for(i=0; i<n; i++)
for(j=0; j<n; j++)
{
if(i!=j)
{
printf("Is there edge between vertex %d and %d(1/0):", i+1,j+1);
scanf("%d", &m[i][j]);
}
}
printf("\nNon recursive breadth first search is :");
bfs(m,n);
}
Slip6
Q1. Write a C program for the Implementation of Prim’s Minimum spanning tree 
algorithm.
#include<stdio.h>
int a,b,u,v,n,i,j,ne=1;
int visited[10]= {0}
,min,mincost=0,cost[10][10];
void main() 
{
printf("\n Enter the number of nodes:");
scanf("%d",&n);
printf("Enter cost in form of adjacency matrix\n");
for (i=1;i<=n;i++)
for (j=1;j<=n;j++) {
scanf("%d",&cost[i][j]);
if(cost[i][j]==0)
cost[i][j]=999;
}
visited[1]=1;
printf("\n");
while(ne<n) 
{
for (i=1,min=999;i<=n;i++)
for (j=1;j<=n;j++)
if(cost[i][j]<min)
if(visited[i]!=0) 
{
min=cost[i][j];
a=u=i;
b=v=j;
}
if(visited[u]==0 || visited[v]==0) 
{
printf("\n Edge %d:(%d %d) cost:%d",ne++,a,b,min);
mincost+=min;
visited[b]=1;
}
cost[a][b]=cost[b][a]=999;
}
printf("\n Minimun cost=%d",mincost);
}
Q 2. Write a C program for the implementation of Dijkstra’s shortest path algorithm for 
findingshortest path from a given source vertex using adjacency cost matrix.
#include<stdio.h>
#define INFINITY 9999
#define MAX 10
void dijkstra(int G[MAX][MAX],int n,int startnode);
int main()
{
int G[MAX][MAX],i,j,n,u;
printf("Enter no. of vertices:");
scanf("%d",&n);
printf("\nEnter the adjacency matrix:\n");
for(i=0;i<n;i++)
for(j=0;j<n;j++)
scanf("%d",&G[i][j]);
printf("\nEnter the starting node:");
scanf("%d",&u);
dijkstra(G,n,u);
return 0;
}
void dijkstra(int G[MAX][MAX],int n,int startnode)
{
int cost[MAX][MAX],distance[MAX],pred[MAX];
int visited[MAX],count,mindistance,nextnode,i,j;
for(i=0;i<n;i++)
for(j=0;j<n;j++)
if(G[i][j]==0)
cost[i][j]=INFINITY;
else
cost[i][j]=G[i][j];
for(i=0;i<n;i++)
{
distance[i]=cost[startnode][i];
pred[i]=startnode;
visited[i]=0;
}
distance[startnode]=0;
visited[startnode]=1;
count=1;
while(count<n-1)
{
mindistance=INFINITY;
for(i=0;i<n;i++)
if(distance[i]<mindistance&&!visited[i])
{
mindistance=distance[i];
nextnode=i;
}
visited[nextnode]=1;
for(i=0;i<n;i++)
if(!visited[i])
if(mindistance+cost[nextnode][i]<distance[i])
{
distance[i]=mindistance+cost[nextnode][i];
pred[i]=nextnode;
}
count++;
}
for(i=0;i<n;i++)
if(i!=startnode)
{
printf("\nDistance of node%d=%d",i,distance[i]);
printf("\nPath=%d",i);
j=i;
do
{
j=pred[j];
printf("<-%d",j);
}
while(j!=startnode);
}
}
OR
Q2 write a c program that accepts the vertices and edges of a graph and stores it as an 
adjacency matrix . Display the adjacency matrix.
#include<stdio.h>
#include<malloc.h>
typedef struct node
{
int vertex;
struct node *next;
}NODE;
NODE *list[10];
void createmat(int m[10][10], int n)
{
int i,j;
char ans;
for(i=0;i<n;i++)
for(j=0;j<n;j++)
{
m[i][i]=0;
if(i!=j)
{
printf("Is there an edge between %d and %d (1/0) ",i+1,j+1);
scanf("%d", &m[i][j]);
}
}}
void dispmat(int m[10][10], int n)
{
int i,j;
printf("\nThe adjacency matrix is :\n");
for(i=0; i<n; i++)
{
for(j=0; j<n; j++)
printf("%5d", m[i][j]);
printf("\n");
}
}
void createlist(int m[10][10], int n)
{
int i,j;
struct node *temp, *newnode;
for(i=0; i<n; i++)
{
list[i]=NULL;
for(j=0; j<n; j++)
{
if(m[i][j]==1)
{
newnode=(NODE *)malloc(sizeof(NODE));newnode->next=NULL;
newnode->vertex=j+1;
if(list [i]==NULL)
list[i]=temp=newnode;
else
{
temp->next=newnode;
temp=newnode;
}
}
}
}
}
void displist(int n)
{
struct node *temp;
int i;
printf("\nThe adjacency list is:\n");
for(i=0; i<n; i++)
{
printf("\nv%d :", i+1);
temp=list[i];
while(temp)
{
printf("v%d ->", temp->vertex);temp=temp->next;
}
printf("NULL");
}
}
void main()
{
int m[10][10], n;
printf("\nEnter the number of vertices:");
scanf("%d", &n);
createmat(m,n);
dispmat(m,n);
createlist(m,n);
displist(n);
}
Slip7
Q 1. Write a C program for the implementation of Floyd Warshall’s algorithm for finding 
all pairs shortest path using adjacency cost matrix.
#include <stdio.h>
#define V 4
#define INF 99999
void printSolution(int dist[][V]);
void floydWarshall(int dist[][V]) {
int i, j, k;
 for (k = 0; k < V; k++) {
 for (i = 0; i < V; i++) {
 for (j = 0; j < V; j++) {
 if (dist[i][k] + dist[k][j] < dist[i][j])
 dist[i][j] = dist[i][k] + dist[k][j];
 }
 }
 }
 printSolution(dist);
}
void printSolution(int dist[][V]) {
 printf("The following matrix shows the shortest distances between every pair of 
vertices:\n");
 for (int i = 0; i < V; i++) {
 for (int j = 0; j < V; j++) {
 if (dist[i][j] == INF)
 printf("%7s", "INF");
 else
 printf("%7d", dist[i][j]);
 }
 printf("\n");
 }
}
int main() {
 int graph[V][V] = { {0, 5, INF, 10},
 {INF, 0, 3, INF},
 {INF, INF, 0, 1},
 {INF, INF, INF, 0} };
 floydWarshall(graph);
 return 0;
}
Q 2. Write a program to sort n randomly generated elements using Heapsort method.
#include<stdio.h>
#include<stdlib.h>
void display(int arr[],int n)
{
int i;
for(i=0; i<n; i++)
printf("%d\t", arr[i]);
}
void heapify(int a[], int top, int last)
{
int j, temp, key;
key = a[top];
j = 2*top+1;
if( (j<last) && (a[j] < a[j+1]) )
j = j+1;
if( (j<=last) && (key<a[j]) )
{
temp = a[top];
a[top] = a[j];
a[j] = temp;
heapify(a,j,last);
}
}void buildheap(int a[], int n)
{
int i;
for(i=n/2-1; i>=0; i--)
heapify(a,i,n-1);
}
void heapsort(int a[], int n)
{
int i, temp, top=0, last;
buildheap(a,n);
printf("Initial heap = ");
display(a,n);
for(last=n-1; last>=1; last--)
{
temp = a[top];
a[top] = a[last];
a[last] = temp;
printf("\n\nAfter iteration %d : ", n-last);
display(a,n);
heapify(a,top,last-1);
}
}
int main(){
int a[8] = {26,5,77,1,61,11,59,15};
heapsort(a,8);
return 0;
}
Slip8
Q 2. Write a program to sort n randomly generated elements using Heapsort method.
#include<stdio.h>
#include<stdlib.h>
void display(int arr[],int n)
{
int i;
for(i=0; i<n; i++)
printf("%d\t", arr[i]);
}
void heapify(int a[], int top, int last)
{
int j, temp, key;
key = a[top];
j = 2*top+1;
if( (j<last) && (a[j] < a[j+1]) )
j = j+1;
if( (j<=last) && (key<a[j]) )
{
temp = a[top];
a[top] = a[j];
a[j] = temp;
heapify(a,j,last);
}
}void buildheap(int a[], int n)
{
int i;
for(i=n/2-1; i>=0; i--)
heapify(a,i,n-1);
}
void heapsort(int a[], int n)
{
int i, temp, top=0, last;
buildheap(a,n);
printf("Initial heap = ");
display(a,n);
for(last=n-1; last>=1; last--)
{
temp = a[top];
a[top] = a[last];
a[last] = temp;
printf("\n\nAfter iteration %d : ", n-last);
display(a,n);
heapify(a,top,last-1);
}
}
int main(){
int a[8] = {26,5,77,1,61,11,59,15};
heapsort(a,8);
return 0;
}
Q2. Write a C program for the Implementation of Prim’s Minimum spanning tree 
algorithm.
#include<stdio.h>
int a,b,u,v,n,i,j,ne=1;
int visited[10]= {0}
,min,mincost=0,cost[10][10];
void main() 
{
printf("\n Enter the number of nodes:");
scanf("%d",&n);
printf("Enter cost in form of adjacency matrix\n");
for (i=1;i<=n;i++)
for (j=1;j<=n;j++) {
scanf("%d",&cost[i][j]);
if(cost[i][j]==0)
cost[i][j]=999;
}
visited[1]=1;
printf("\n");
while(ne<n) 
{
for (i=1,min=999;i<=n;i++)
for (j=1;j<=n;j++)
if(cost[i][j]<min)
if(visited[i]!=0) 
{
min=cost[i][j];
a=u=i;
b=v=j;
}
if(visited[u]==0 || visited[v]==0) 
{
printf("\n Edge %d:(%d %d) cost:%d",ne++,a,b,min);
mincost+=min;
visited[b]=1;
}
cost[a][b]=cost[b][a]=999;
}
printf("\n Minimun cost=%d",mincost);
}
Slip9
Q 1. Write a C program that accepts the vertices and edges of a graph. Create 
adjacency list and display the adjacency list.
#include<stdio.h>
#include<stdio.h>
#include<malloc.h>
typedef struct node
{
int vertex;
struct node *next;
}NODE;
NODE *list[10];
void createmat(int m[10][10], int n)
{
int i,j;
char ans;
for(i=0;i<n;i++)
for(j=0;j<n;j++)
{
m[i][i]=0;
if(i!=j)
{
printf("Is there an edge between %d and %d (1/0) ",i+1,j+1);
scanf("%d", &m[i][j]);
}
}}
void createlist(int m[10][10], int n)
{
int i,j;
struct node *temp, *newnode;
for(i=0; i<n; i++)
{
list[i]=NULL;
for(j=0; j<n; j++)
{
if(m[i][j]==1)
{
newnode=(NODE *)malloc(sizeof(NODE));newnode->next=NULL;
newnode->vertex=j+1;
if(list [i]==NULL)
list[i]=temp=newnode;
else
{
temp->next=newnode;
temp=newnode;
}
}
}
}
}
void displist(int n)
{
struct node *temp;
int i;
printf("\nThe adjacency list is:\n");
for(i=0; i<n; i++)
{
printf("\nv%d :", i+1);
temp=list[i];
while(temp)
{
printf("v%d ->", temp->vertex);temp=temp->next;
}
printf("NULL");
}
}
void main()
{
int m[10][10], n;
printf("\nEnter the number of vertices:");
scanf("%d", &n);
createmat(m,n);
createlist(m,n);
displist(n);
}
Q 2. Implement a Binary search tree (BST) library (btree.h) with operations – create, 
insert, preorder. Write a menu driven program that performs the above operations.
#include <stdio.h>
#include <stdlib.h>
typedef struct Node{
int data;
struct Node* left;
struct Node* right;
}Node;
Node* root = NULL;
Node* newNode(int d){
Node* newnode = (Node*)malloc(sizeof(Node));
newnode->data = d;
newnode->left = NULL;
newnode->right = NULL;
return newnode;
}
Node* buildBST(Node* root,int x){
if(root == NULL){
root = newNode(x);
return root;
}
else if(root->data > x){
root->left = buildBST(root->left,x);
}
else{
root->right = buildBST(root->right,x);
}
return root;
}
void solve(){
int data;
printf("Enter the data\n");
scanf("%d",&data);
while(data!=-1){
root = buildBST(root,data);
scanf("%d",&data);
}
}
int search(Node* root,int x){
if(root == NULL){
return 0;
}
else if(root->data == x){
return 1;
}
else if(root -> data > x){
return search(root->left,x);
}
else{
return search(root->right,x);
}
}
int searchBST(){
int data;
printf("Enter data to be searched\n");
scanf("%d",&data);
int ans;
ans = search(root,data);
if(ans == 1){
printf("data is present\n");
}
else{
printf("data is not present\n");
}
}
void inorder(Node* root){
if(root==NULL){
return;
}
inorder(root->left);
printf("%d ",root->data);
inorder(root->right);
}
void postorder(Node* root){
if(root==NULL){
return;
}
inorder(root->left);
inorder(root->right);
printf("%d ",root->data);
}
void preorder(Node* root){
if(root==NULL){
return;
}
printf("%d ",root->data);
inorder(root->left);
inorder(root->right);
}
int main(){
solve();
printf("\n");
printf("ROOT data = %d\n",root->data);
printf("Inorder Traversal : \n");
inorder(root);
printf("preorder Traversal : \n");
preorder(root);printf("\n");
printf("postorder Traversal : \n");
postorder(root);printf("\n");
printf("\n");
searchBST();
return 0;
}
OR
Q 2. Write a C program that accepts the vertices and edges of a graph and store it as 
an adjacency matrix. Implement function to traverse the graph using Depth First 
Search (DFS) traversal
#include<stdio.h>
#define MAX 10
typedef struct
{
int data[MAX];
int top;
}STACK;
void initstack(STACK * ps)
{
ps->top=-1;
}
void push(STACK *ps, int num)
{
ps->data[++ps->top]=num;
}
int pop(STACK *ps)
{
return(ps->data[ps->top--]);
}
int isempty(STACK *ps)
{
return(ps->top==-1);
}
int isfull(STACK *ps){
return (ps->top==MAX-1);
}
void dfs(int m[10][10], int n)
{
int i, v, w, found;
int visited[10]={0};
STACK s;
initstack(&s);
v=0;
visited[v]=1;
push(&s,v);
printf("v%d" ,v+1);
while(1)
{
found=0;
for(w=0; w<n; w++)
{
if((m[v][w]==1)&&(visited[w]==0))
{
push(&s, w);
printf("v%d", w+1);
visited[w]=1;
v = w;
found = 1;break;
}
}
if(found == 0)// did not find an adjacent unvisited vertex
if(isempty(&s))
break;
else
v = pop(&s);
}
}
int recdfs(int m[10][10], int n, int v)
{
int w;
static int visited[10]={0};
visited[v]=1;
printf("v%d" ,v+1);
for(w=0; w<n; w++)
{
if( (m[v] [w]==1) && (visited[w]==0) )
recdfs(m,n,w);
}
}
int main()
{int m[10][10], n, i, j, w;
printf("\nHow many vertices:");
scanf("%d", &n);
for(i=0; i<n; i++)
for(j=0; j<n; j++)
{
if(i!=j)
{
printf("Is there edge between vertex %d and %d(1/0):", i+1, j+1);
scanf("%d", &m[i][j]);
}
}
printf("\nNon recursive depth first search is :");
dfs(m,n);
printf("\nRecursive depth first search is :");
recdfs(m,n,0);
}
Slip10
Q 1. Implement a Binary search tree (BST) library (btree.h) with operations – create, 
insert, preorder. Write a menu driven program that performs the above operations.
#include <stdio.h>
#include <stdlib.h>
typedef struct Node{
int data;
struct Node* left;
struct Node* right;
}Node;
Node* root = NULL;
Node* newNode(int d){
Node* newnode = (Node*)malloc(sizeof(Node));
newnode->data = d;
newnode->left = NULL;
newnode->right = NULL;
return newnode;
}
Node* buildBST(Node* root,int x){
if(root == NULL){
root = newNode(x);
return root;
}
else if(root->data > x){
root->left = buildBST(root->left,x);
}
else{
root->right = buildBST(root->right,x);
}
return root;
}
void solve(){
int data;
printf("Enter the data\n");
scanf("%d",&data);
while(data!=-1){
root = buildBST(root,data);
scanf("%d",&data);
}
}
int search(Node* root,int x){
if(root == NULL){
return 0;
}
else if(root->data == x){
return 1;
}
else if(root -> data > x){
return search(root->left,x);
}
else{
return search(root->right,x);
}
}
int searchBST(){
int data;
printf("Enter data to be searched\n");
scanf("%d",&data);
int ans;
ans = search(root,data);
if(ans == 1){
printf("data is present\n");
}
else{
printf("data is not present\n");
}
}
void inorder(Node* root){
if(root==NULL){
return;
}
inorder(root->left);
printf("%d ",root->data);
inorder(root->right);
}
void postorder(Node* root){
if(root==NULL){
return;
}
inorder(root->left);
inorder(root->right);
printf("%d ",root->data);
}
void preorder(Node* root){
if(root==NULL){
return;
}
printf("%d ",root->data);
inorder(root->left);
inorder(root->right);
}
int main(){
solve();
printf("\n");
printf("ROOT data = %d\n",root->data);
printf("Inorder Traversal : \n");
inorder(root);
printf("preorder Traversal : \n");
preorder(root);printf("\n");
printf("postorder Traversal : \n");
postorder(root);printf("\n");
printf("\n");
searchBST();
return 0;
}
Q 2. Write a C program that accepts the vertices and edges of a graph. Create 
adjacency list and display the adjacency list.
#include<stdio.h>
#include<stdio.h>
#include<malloc.h>
typedef struct node
{
int vertex;
struct node *next;
}NODE;
NODE *list[10];
void createmat(int m[10][10], int n)
{
int i,j;
char ans;
for(i=0;i<n;i++)
for(j=0;j<n;j++)
{
m[i][i]=0;
if(i!=j)
{
printf("Is there an edge between %d and %d (1/0) ",i+1,j+1);
scanf("%d", &m[i][j]);
}
}}
void createlist(int m[10][10], int n)
{
int i,j;
struct node *temp, *newnode;
for(i=0; i<n; i++)
{
list[i]=NULL;
for(j=0; j<n; j++)
{
if(m[i][j]==1)
{
newnode=(NODE *)malloc(sizeof(NODE));newnode->next=NULL;
newnode->vertex=j+1;
if(list [i]==NULL)
list[i]=temp=newnode;
else
{
temp->next=newnode;
temp=newnode;
}
}
}
}
}
void displist(int n)
{
struct node *temp;
int i;
printf("\nThe adjacency list is:\n");
for(i=0; i<n; i++)
{
printf("\nv%d :", i+1);
temp=list[i];
while(temp)
{
printf("v%d ->", temp->vertex);temp=temp->next;
}
printf("NULL");
}
}
void main()
{
int m[10][10], n;
printf("\nEnter the number of vertices:");
scanf("%d", &n);
createmat(m,n);
createlist(m,n);
displist(n);
}
OR
Q 2. Write a C program that accepts the vertices and edges of a graph and store it as 
an adjacency matrix. Implement function to traverse the graph using Breadth First 
Search (BFS) traversal.
#include<stdio.h>
#define MAX 10
typedef struct
{
int data[MAX];
int front, rear;
}QUEUE;
/**functions****/
void initq(QUEUE *pq)
{
pq->front = pq->rear = -1;
}
void addq(QUEUE *pq, int num)
{
pq->rear++;
pq->data[pq->rear] = num;
}
int removeq(QUEUE *pq)
{
int num;
pq->front++;
num=pq->data[pq->front];
return(num);
}int isempty(QUEUE *pq)
{
return(pq->front == pq->rear);
}
int isfull(QUEUE *pq)
{
return(pq->rear==MAX-1);
}
void bfs(int m[10][10], int n)
{
int i, v, w;
int visited[10]={0};
QUEUE q;
initq(&q);
v=0;
visited[v]=1;
addq(&q,v);
while(!isempty(&q))
{
v=removeq(&q);
printf("v%d",v+1);
for(w=0; w<n; w++)
{
if((m[v][w]==1)&&(visited[w]==0)){
addq(&q, w);
visited[w]=1;
}
}
}
}
int main()
{
int m[10][10], n, i, j, w;
printf("\nHow many vertices:");
scanf("%d", &n);
for(i=0; i<n; i++)
for(j=0; j<n; j++)
{
if(i!=j)
{
printf("Is there edge between vertex %d and %d(1/0):", i+1,j+1);
scanf("%d", &m[i][j]);
}
}
printf("\nNon recursive breadth first search is :");
bfs(m,n);
}
Slip11
Q 1. Write a C program for the implementation of Floyd Warshall’s algorithm for finding 
all pairs shortest path using adjacency cost matrix.
#include <stdio.h>
#define V 4
#define INF 99999
void printSolution(int dist[][V]);
void floydWarshall(int dist[][V]) {
int i, j, k;
 for (k = 0; k < V; k++) {
 for (i = 0; i < V; i++) {
 for (j = 0; j < V; j++) {
 if (dist[i][k] + dist[k][j] < dist[i][j])
 dist[i][j] = dist[i][k] + dist[k][j];
 }
 }
 }
 printSolution(dist);
}
void printSolution(int dist[][V]) {
 printf("The following matrix shows the shortest distances between every pair of 
vertices:\n");
 for (int i = 0; i < V; i++) {
 for (int j = 0; j < V; j++) {
 if (dist[i][j] == INF)
 printf("%7s", "INF");
 else
 printf("%7d", dist[i][j]);
 }
 printf("\n");
 }
}
int main() {
 int graph[V][V] = { {0, 5, INF, 10},
 {INF, 0, 3, INF},
 {INF, INF, 0, 1},
 {INF, INF, INF, 0} };
 floydWarshall(graph);
 return 0;
}
Q 2. Write a C program that accepts the vertices and edges of a graph. Create 
adjacency list and display the adjacency list.
#include<stdio.h>
#include<stdio.h>
#include<malloc.h>
typedef struct node
{
int vertex;
struct node *next;
}NODE;
NODE *list[10];
void createmat(int m[10][10], int n)
{
int i,j;
char ans;
for(i=0;i<n;i++)
for(j=0;j<n;j++)
{
m[i][i]=0;
if(i!=j)
{
printf("Is there an edge between %d and %d (1/0) ",i+1,j+1);
scanf("%d", &m[i][j]);
}
}}
void createlist(int m[10][10], int n)
{
int i,j;
struct node *temp, *newnode;
for(i=0; i<n; i++)
{
list[i]=NULL;
for(j=0; j<n; j++)
{
if(m[i][j]==1)
{
newnode=(NODE *)malloc(sizeof(NODE));newnode->next=NULL;
newnode->vertex=j+1;
if(list [i]==NULL)
list[i]=temp=newnode;
else
{
temp->next=newnode;
temp=newnode;
}
}
}
}
}
void displist(int n)
{
struct node *temp;
int i;
printf("\nThe adjacency list is:\n");
for(i=0; i<n; i++)
{
printf("\nv%d :", i+1);
temp=list[i];
while(temp)
{
printf("v%d ->", temp->vertex);temp=temp->next;
}
printf("NULL");
}
}
void main()
{
int m[10][10], n;
printf("\nEnter the number of vertices:");
scanf("%d", &n);
createmat(m,n);
createlist(m,n);
displist(n);
}
OR
Q 2. Write a C program that accepts the vertices and edges of a graph and store it as 
an adjacency matrix. Implement function to traverse the graph using Depth First 
Search (DFS) traversal
#include<stdio.h>
#define MAX 10
typedef struct
{
int data[MAX];
int top;
}STACK;
void initstack(STACK * ps)
{
ps->top=-1;
}
void push(STACK *ps, int num)
{
ps->data[++ps->top]=num;
}
int pop(STACK *ps)
{
return(ps->data[ps->top--]);
}
int isempty(STACK *ps)
{
return(ps->top==-1);
}
int isfull(STACK *ps){
return (ps->top==MAX-1);
}
void dfs(int m[10][10], int n)
{
int i, v, w, found;
int visited[10]={0};
STACK s;
initstack(&s);
v=0;
visited[v]=1;
push(&s,v);
printf("v%d" ,v+1);
while(1)
{
found=0;
for(w=0; w<n; w++)
{
if((m[v][w]==1)&&(visited[w]==0))
{
push(&s, w);
printf("v%d", w+1);
visited[w]=1;
v = w;
found = 1;break;
}
}
if(found == 0)// did not find an adjacent unvisited vertex
if(isempty(&s))
break;
else
v = pop(&s);
}
}
int recdfs(int m[10][10], int n, int v)
{
int w;
static int visited[10]={0};
visited[v]=1;
printf("v%d" ,v+1);
for(w=0; w<n; w++)
{
if( (m[v] [w]==1) && (visited[w]==0) )
recdfs(m,n,w);
}
}
int main()
{int m[10][10], n, i, j, w;
printf("\nHow many vertices:");
scanf("%d", &n);
for(i=0; i<n; i++)
for(j=0; j<n; j++)
{
if(i!=j)
{
printf("Is there edge between vertex %d and %d(1/0):", i+1, j+1);
scanf("%d", &m[i][j]);
}
}
printf("\nNon recursive depth first search is :");
dfs(m,n);
printf("\nRecursive depth first search is :");
recdfs(m,n,0);
}
Slip12
Q 1. Implement a Binary search tree (BST) library (btree.h) with operations – create, 
insert, preorder. Write a menu driven program that performs the above operations.
#include <stdio.h>
#include <stdlib.h>
typedef struct Node{
int data;
struct Node* left;
struct Node* right;
}Node;
Node* root = NULL;
Node* newNode(int d){
Node* newnode = (Node*)malloc(sizeof(Node));
newnode->data = d;
newnode->left = NULL;
newnode->right = NULL;
return newnode;
}
Node* buildBST(Node* root,int x){
if(root == NULL){
root = newNode(x);
return root;
}
else if(root->data > x){
root->left = buildBST(root->left,x);
}
else{
root->right = buildBST(root->right,x);
}
return root;
}
void solve(){
int data;
printf("Enter the data\n");
scanf("%d",&data);
while(data!=-1){
root = buildBST(root,data);
scanf("%d",&data);
}
}
int search(Node* root,int x){
if(root == NULL){
return 0;
}
else if(root->data == x){
return 1;
}
else if(root -> data > x){
return search(root->left,x);
}
else{
return search(root->right,x);
}
}
int searchBST(){
int data;
printf("Enter data to be searched\n");
scanf("%d",&data);
int ans;
ans = search(root,data);
if(ans == 1){
printf("data is present\n");
}
else{
printf("data is not present\n");
}
}
void inorder(Node* root){
if(root==NULL){
return;
}
inorder(root->left);
printf("%d ",root->data);
inorder(root->right);
}
void postorder(Node* root){
if(root==NULL){
return;
}
inorder(root->left);
inorder(root->right);
printf("%d ",root->data);
}
void preorder(Node* root){
if(root==NULL){
return;
}
printf("%d ",root->data);
inorder(root->left);
inorder(root->right);
}
int main(){
solve();
printf("\n");
printf("ROOT data = %d\n",root->data);
printf("Inorder Traversal : \n");
inorder(root);
printf("preorder Traversal : \n");
preorder(root);printf("\n");
printf("postorder Traversal : \n");
postorder(root);printf("\n");
printf("\n");
searchBST();
return 0;
}
Q2. Write a C program for the implementation of Topological sorting.
#include <stdio.h>
int main(){
int i,j,k,n,a[10][10],indeg[10],flag[10],count=0;
printf("Enter the no of vertices:\n");
scanf("%d",&n);
printf("Enter the adjacency matrix:\n");
for(i=0;i<n;i++){
printf("Enter row %d\n",i+1);
for(j=0;j<n;j++)
scanf("%d",&a[i][j]);
}
for(i=0;i<n;i++)
{
indeg[i]=0;
flag[i]=0;
}
for(i=0;i<n;i++)
for(j=0;j<n;j++)
indeg[i]=indeg[i]+a[j][i];
printf("\nThe topological order is:");
while(count<n)
{
for(k=0;k<n;k++){
if((indeg[k]==0) && (flag[k]==0))
{
printf("%d ",(k+1));
flag [k]=1;
}
for(i=0;i<n;i++){
if(a[i][k]==1)
indeg[k]--;
}
}
count++;
}
return 0;
}
OR
Q 2. Write a C program that acceptsthe vertices and edges of a graph and store it as an 
adjacency matrix. Implement functions to print indegree, outdegree and total degree 
of all vertices of graph.
#include <stdio.h>
void main()
{
int m[10][10],r,c,sumin,sumout,n,v,i;
printf("how many vertices:");
scanf("%d",&n);
for(r=0;r<n;r++)
for(c=0;c<n;c++)
 {
 m[r][c]=0;
 if(r!=c)
 {
 printf("is there an edge between %d and %d(1/0):",r+1,c+1);
 scanf("%d",&m[r][c]);
 }
 }
printf("\n\nVertex Indegree Outdegree Total degree\n");
for(v=0;v<n;v++)
 {
 sumin=sumout=0;
 for(i=0;i<n;i++)
 {
 sumin=sumin+m[i][v];
 sumout=sumout+m[v][i];
 }
 printf("%d\t\t%d\t\t%d\t\t%d\n",v+1,sumin,sumout,sumin+sumout);
 }
}
Slip13
Q 1. Write a C program for the Implementation of Kruskal’s Minimum spanning tree 
algorithm.
#include <stdio.h>
#include <stdlib.h>
int i, j, k, a, b, u, v, n, ne = 1;
int min, mincost = 0, cost[9][9], parent[9];
int find(int);
int uni(int, int);
void main()
{
printf("Kruskal's algorithm in C\n");
printf("========================\n");
printf("Enter the no. of vertices:\n");
scanf("%d", &n);
printf("\nEnter the cost adjacency matrix:\n");
for (i = 1; i <= n; i++)
{
for (j = 1; j <= n; j++)
{
scanf("%d", &cost[i][j]);
if (cost[i][j] == 0)
cost[i][j] = 999;
}
}
printf("The edges of Minimum Cost Spanning Tree are\n");
while (ne < n)
{
for (i = 1, min = 999; i <= n; i++)
{
for (j = 1; j <= n; j++)
{
if (cost[i][j] < min)
{
min = cost[i][j];
a = u = i;
b = v = j;
}
}
}
u = find(u);
v = find(v);
if (uni(u, v))
{
printf("%d edge (%d,%d) =%d\n", ne++, a, b, min);
mincost += min;
}
cost[a][b] = cost[b][a] = 999;
}
printf("\nMinimum cost = %d\n", mincost);
}
int find(int i)
{
while (parent[i])
i = parent[i];
return i;
}
int uni(int i, int j)
{
if (i != j)
{
parent[j] = i;
return 1;
}
 
return 0;
}
Q 2. Write a program which uses binary search tree library and counts the total nodes 
and total leaf nodes in the tree. int countLeaf(T) – returns the total number of leaf 
nodes from BST
#include <stdio.h>
#include <stdlib.h>
typedef struct Node{
int data;
struct Node* left;
struct Node* right;
}Node;
Node* root = NULL;
int totalNodes = 0;
int totalleaf = 0;
Node* newNode(int d){
Node* newnode = (Node*)malloc(sizeof(Node));
newnode->data = d;
newnode->left = NULL;
newnode->right = NULL;
return newnode;
}
Node* buildBST(Node* root,int x){
if(root == NULL){
root = newNode(x);
return root;
}
else if(root->data > x){
root->left = buildBST(root->left,x);
}
else{
root->right = buildBST(root->right,x);
}
return root;
}
void solve(){
int data;
printf("Enter the data\n");
scanf("%d",&data);
while(data!=-1){
root = buildBST(root,data);
scanf("%d",&data);
}
}
void countNodes(Node* root){
if(root == NULL){
return;
}
if(root!=NULL){
totalNodes++;
}
countNodes(root->left);
countNodes(root->right);
}
void countleaf(Node* root){
if(root==NULL)
return;
if(root->left == NULL && root->right == NULL){
totalleaf++;
return;
}
countleaf(root->left);
countleaf(root->right);
}
int main(){
solve();
printf("\n");
countNodes(root);
countleaf(root);
printf("total Nodes = %d",totalNodes);
printf("Total leaf Nodes = %d",totalleaf);
return 0;
}
OR
Q 2. Write a C program that accepts the vertices and edges of a graph and store it as 
an adjacency matrix. Implement function to traverse the graph using Breadth First 
Search (BFS) traversal.
#include<stdio.h>
#define MAX 10
typedef struct
{
int data[MAX];
int front, rear;
}QUEUE;
/**functions****/
void initq(QUEUE *pq)
{
pq->front = pq->rear = -1;
}
void addq(QUEUE *pq, int num)
{
pq->rear++;
pq->data[pq->rear] = num;
}
int removeq(QUEUE *pq)
{
int num;
pq->front++;
num=pq->data[pq->front];
return(num);
}int isempty(QUEUE *pq)
{
return(pq->front == pq->rear);
}
int isfull(QUEUE *pq)
{
return(pq->rear==MAX-1);
}
void bfs(int m[10][10], int n)
{
int i, v, w;
int visited[10]={0};
QUEUE q;
initq(&q);
v=0;
visited[v]=1;
addq(&q,v);
while(!isempty(&q))
{
v=removeq(&q);
printf("v%d",v+1);
for(w=0; w<n; w++)
{
if((m[v][w]==1)&&(visited[w]==0)){
addq(&q, w);
visited[w]=1;
}
}
}
}
int main()
{
int m[10][10], n, i, j, w;
printf("\nHow many vertices:");
scanf("%d", &n);
for(i=0; i<n; i++)
for(j=0; j<n; j++)
{
if(i!=j)
{
printf("Is there edge between vertex %d and %d(1/0):", i+1,j+1);
scanf("%d", &m[i][j]);
}
}
printf("\nNon recursive breadth first search is :");
bfs(m,n);
}
Slip14
Q 1. Write a C program for the implementation of Floyd Warshall’s algorithm for finding 
all pairs shortest path using adjacency cost matrix.
#include <stdio.h>
#define V 4
#define INF 99999
void printSolution(int dist[][V]);
void floydWarshall(int dist[][V]) {
int i, j, k;
 for (k = 0; k < V; k++) {
 for (i = 0; i < V; i++) {
 for (j = 0; j < V; j++) {
 if (dist[i][k] + dist[k][j] < dist[i][j])
 dist[i][j] = dist[i][k] + dist[k][j];
 }
 }
 }
 printSolution(dist);
}
void printSolution(int dist[][V]) {
 printf("The following matrix shows the shortest distances between every pair of 
vertices:\n");
 for (int i = 0; i < V; i++) {
 for (int j = 0; j < V; j++) {
 if (dist[i][j] == INF)
 printf("%7s", "INF");
 else
 printf("%7d", dist[i][j]);
 }
 printf("\n");
 }
}
int main() {
 int graph[V][V] = { {0, 5, INF, 10},
 {INF, 0, 3, INF},
 {INF, INF, 0, 1},
 {INF, INF, INF, 0} };
 floydWarshall(graph);
 return 0;
}
Q2. Write a menu driven program to implement hash table using array (insert, search, 
display). Use any of the above-mentioned hash functions. In case of collision apply 
linear probing.
#include <stdio.h>
#include <stdlib.h>
#define TABLE_SIZE 10
struct HashEntry 
{
 int key;
 int data;
};
struct HashTable 
{
 struct HashEntry* table[TABLE_SIZE];
};
int hashFunction(int data);
int linearProbe(int index);
void insert(struct HashTable* ht, int data);
int search(struct HashTable* ht, int data);
void delete(struct HashTable* ht, int data);
void display(struct HashTable* ht);
void initializeHashTable(struct HashTable* ht);
int main() 
{
 struct HashTable ht;
 int choice, data;
 initializeHashTable(&ht);
 while (1) 
 {
 printf("\nMenu:\n");
 printf("1. Insert\n");
 printf("2. Search\n");
 printf("3. Delete\n");
 printf("4. Display\n");
 printf("5. Exit\n");
 printf("Enter your choice: ");
 scanf("%d", &choice);
 switch (choice) 
 {
 case 1:
 printf("Enter data to insert: ");
 scanf("%d", &data);
 insert(&ht, data);
 break;
 case 2:
 printf("Enter data to search: ");
 scanf("%d", &data);
 if (search(&ht, data) != -1)
 printf("Data found.\n");
 else
 printf("Data not found.\n");
 break;
 case 3:
 printf("Enter data to delete: ");
 scanf("%d", &data);
 delete(&ht, data);
 break;
 case 4:
 display(&ht);
 break;
 case 5:
 exit(0);
 default:
 printf("Invalid choice.\n");
 }
 }
 return 0;
}
int hashFunction(int data) 
{
 return data % TABLE_SIZE;
}
int linearProbe(int index) 
{
 return (index + 1) % TABLE_SIZE;
}
void insert(struct HashTable* ht, int data)
{
 int index = hashFunction(data);
 int originalIndex=index;
 while (ht->table[ index] != NULL) 
 {
 index = linearProbe(index);
 if(index==originalIndex)
 {
 printf("Hash Table is full. Cannot Insert. \n");
 return;
 }
 }
 ht->table[index] = (struct HashEntry*)malloc(sizeof(struct HashEntry));
 ht->table[index]->key = data; 
 ht->table[index]->data = data;
 printf("Inserted data %d with key %d at index %d.\n", data, data, index);
}
int search(struct HashTable* ht, int data)
{
 int index = hashFunction(data);
 int originalIndex = index;
 while (ht->table[index] != NULL) 
 {
 if (ht->table[index]->data == data)
 return index;
 index = linearProbe(index);
 if (index == originalIndex)
 break;
 }
 return -1;
}
void delete(struct HashTable* ht, int data) {
 int index = search(ht, data);
 if (index != -1) {
 free(ht->table[index]);
 ht->table[index] = NULL;
 printf("Deleted data %d.\n", data);
 } else {
 printf("Data not found. Cannot delete.\n");
 }
}
void display(struct HashTable* ht) 
{
int i;
 printf("Hash Table:\n");
 for (i = 0; i < TABLE_SIZE; i++) 
 {
 if (ht->table[i] != NULL)
 printf("Index %d: Key = %d, Data = %d\n", i, ht->table[i]->key, ht->table[i]->data);
 else
 printf("Index %d: Empty\n", i);
 }
}
void initializeHashTable(struct HashTable* ht) 
{
int i;
 for (i = 0; i < TABLE_SIZE; i++)
 ht->table[i] = NULL;
}
Slip15
Q1. Write a C program for the Implementation of Prim’s Minimum spanning tree 
algorithm.
#include<stdio.h>
int a,b,u,v,n,i,j,ne=1;
int visited[10]= {0}
,min,mincost=0,cost[10][10];
void main() 
{
printf("\n Enter the number of nodes:");
scanf("%d",&n);
printf("Enter cost in form of adjacency matrix\n");
for (i=1;i<=n;i++)
for (j=1;j<=n;j++) {
scanf("%d",&cost[i][j]);
if(cost[i][j]==0)
cost[i][j]=999;
}
visited[1]=1;
printf("\n");
while(ne<n) 
{
for (i=1,min=999;i<=n;i++)
for (j=1;j<=n;j++)
if(cost[i][j]<min)
if(visited[i]!=0) 
{
min=cost[i][j];
a=u=i;
b=v=j;
}
if(visited[u]==0 || visited[v]==0) 
{
printf("\n Edge %d:(%d %d) cost:%d",ne++,a,b,min);
mincost+=min;
visited[b]=1;
}
cost[a][b]=cost[b][a]=999;
}
printf("\n Minimun cost=%d",mincost);
}
Q 2. Write a C program for the implementation of Dijkstra’s shortest path algorithm for 
findingshortest path from a given source vertex using adjacency cost matrix.
#include<stdio.h>
#define INFINITY 9999
#define MAX 10
void dijkstra(int G[MAX][MAX],int n,int startnode);
int main()
{
int G[MAX][MAX],i,j,n,u;
printf("Enter no. of vertices:");
scanf("%d",&n);
printf("\nEnter the adjacency matrix:\n");
for(i=0;i<n;i++)
for(j=0;j<n;j++)
scanf("%d",&G[i][j]);
printf("\nEnter the starting node:");
scanf("%d",&u);
dijkstra(G,n,u);
return 0;
}
void dijkstra(int G[MAX][MAX],int n,int startnode)
{
int cost[MAX][MAX],distance[MAX],pred[MAX];
int visited[MAX],count,mindistance,nextnode,i,j;
for(i=0;i<n;i++)
for(j=0;j<n;j++)
if(G[i][j]==0)
cost[i][j]=INFINITY;
else
cost[i][j]=G[i][j];
for(i=0;i<n;i++)
{
distance[i]=cost[startnode][i];
pred[i]=startnode;
visited[i]=0;
}
distance[startnode]=0;
visited[startnode]=1;
count=1;
while(count<n-1)
{
mindistance=INFINITY;
for(i=0;i<n;i++)
if(distance[i]<mindistance&&!visited[i])
{
mindistance=distance[i];
nextnode=i;
}
visited[nextnode]=1;
for(i=0;i<n;i++)
if(!visited[i])
if(mindistance+cost[nextnode][i]<distance[i])
{
distance[i]=mindistance+cost[nextnode][i];
pred[i]=nextnode;
}
count++;
}
for(i=0;i<n;i++)
if(i!=startnode)
{
printf("\nDistance of node%d=%d",i,distance[i]);
printf("\nPath=%d",i);
j=i;
do
{
j=pred[j];
printf("<-%d",j);
}
while(j!=startnode);
}
}
OR
Q 2. Write a C program that accepts the vertices and edges of a graph and store it as 
an adjacency matrix. Implement function to traverse the graph using Breadth First 
Search (BFS) traversal.
#include<stdio.h>
#define MAX 10
typedef struct
{
int data[MAX];
int front, rear;
}QUEUE;
/**functions****/
void initq(QUEUE *pq)
{
pq->front = pq->rear = -1;
}
void addq(QUEUE *pq, int num)
{
pq->rear++;
pq->data[pq->rear] = num;
}
int removeq(QUEUE *pq)
{
int num;
pq->front++;
num=pq->data[pq->front];
return(num);
}int isempty(QUEUE *pq)
{
return(pq->front == pq->rear);
}
int isfull(QUEUE *pq)
{
return(pq->rear==MAX-1);
}
void bfs(int m[10][10], int n)
{
int i, v, w;
int visited[10]={0};
QUEUE q;
initq(&q);
v=0;
visited[v]=1;
addq(&q,v);
while(!isempty(&q))
{
v=removeq(&q);
printf("v%d",v+1);
for(w=0; w<n; w++)
{
if((m[v][w]==1)&&(visited[w]==0)){
addq(&q, w);
visited[w]=1;
}
}
}
}
int main()
{
int m[10][10], n, i, j, w;
printf("\nHow many vertices:");
scanf("%d", &n);
for(i=0; i<n; i++)
for(j=0; j<n; j++)
{
if(i!=j)
{
printf("Is there edge between vertex %d and %d(1/0):", i+1,j+1);
scanf("%d", &m[i][j]);
}
}
printf("\nNon recursive breadth first search is :");
bfs(m,n);
}
Slip16
Q 1. Write a C program for the implementation of Floyd Warshall’s algorithm for finding 
all pairs shortest path using adjacency cost matrix.
#include <stdio.h>
#define V 4
#define INF 99999
void printSolution(int dist[][V]);
void floydWarshall(int dist[][V]) {
int i, j, k;
 for (k = 0; k < V; k++) {
 for (i = 0; i < V; i++) {
 for (j = 0; j < V; j++) {
 if (dist[i][k] + dist[k][j] < dist[i][j])
 dist[i][j] = dist[i][k] + dist[k][j];
 }
 }
 }
 printSolution(dist);
}
void printSolution(int dist[][V]) {
 printf("The following matrix shows the shortest distances between every pair of 
vertices:\n");
 for (int i = 0; i < V; i++) {
 for (int j = 0; j < V; j++) {
 if (dist[i][j] == INF)
 printf("%7s", "INF");
 else
 printf("%7d", dist[i][j]);
 }
 printf("\n");
 }
}
int main() {
 int graph[V][V] = { {0, 5, INF, 10},
 {INF, 0, 3, INF},
 {INF, INF, 0, 1},
 {INF, INF, INF, 0} };
 floydWarshall(graph);
 return 0;
}
Q 2. Write a program to sort n randomly generated elements using Heapsort method.
#include<stdio.h>
#include<stdlib.h>
void display(int arr[],int n)
{
int i;
for(i=0; i<n; i++)
printf("%d\t", arr[i]);
}
void heapify(int a[], int top, int last)
{
int j, temp, key;
key = a[top];
j = 2*top+1;
if( (j<last) && (a[j] < a[j+1]) )
j = j+1;
if( (j<=last) && (key<a[j]) )
{
temp = a[top];
a[top] = a[j];
a[j] = temp;
heapify(a,j,last);
}
}void buildheap(int a[], int n)
{
int i;
for(i=n/2-1; i>=0; i--)
heapify(a,i,n-1);
}
void heapsort(int a[], int n)
{
int i, temp, top=0, last;
buildheap(a,n);
printf("Initial heap = ");
display(a,n);
for(last=n-1; last>=1; last--)
{
temp = a[top];
a[top] = a[last];
a[last] = temp;
printf("\n\nAfter iteration %d : ", n-last);
display(a,n);
heapify(a,top,last-1);
}
}
int main(){
int a[8] = {26,5,77,1,61,11,59,15};
heapsort(a,8);
return 0;
}
Slip17
Q1. Write a menu driven program to implement hash table using array (insert, search, 
display). Use any of the above-mentioned hash functions. In case of collision apply 
linear probing.
#include <stdio.h>
#include <stdlib.h>
#define TABLE_SIZE 10
struct HashEntry 
{
 int key;
 int data;
};
struct HashTable 
{
 struct HashEntry* table[TABLE_SIZE];
};
int hashFunction(int data);
int quadraticProbe(int index, int attempt);
void insert(struct HashTable* ht, int data);
int search(struct HashTable* ht, int data);
void delete(struct HashTable* ht, int data);
void display(struct HashTable* ht);
void initializeHashTable(struct HashTable* ht);
int main() 
{
 struct HashTable ht;
 int choice, data;
 initializeHashTable(&ht);
 while (1) {
 printf("\nMenu:\n");
 printf("1. Insert\n");
 printf("2. Search\n");
 printf("3. Delete\n");
 printf("4. Display\n");
 printf("5. Exit\n");
 printf("Enter your choice: ");
 scanf("%d", &choice);
 switch (choice) 
 {
 case 1:
 printf("Enter data to insert: ");
 scanf("%d", &data);
 insert(&ht, data);
 break;
 case 2:
 printf("Enter data to search: ");
 scanf("%d", &data);
 if (search(&ht, data) != -1)
 printf("Data found.\n");
 else
 printf("Data not found.\n");
 break;
 case 3:
 printf("Enter data to delete: ");
 scanf("%d", &data);
 delete(&ht, data);
 break;
 case 4:
 display(&ht);
 break;
 case 5:
 exit(0);
 default:
 printf("Invalid choice.\n");
 }
 }
 return 0;
}
int hashFunction(int data) 
{
 return data % TABLE_SIZE;
}
int quadraticProbe(int index, int attempt) 
{
 return (index + attempt * attempt) % TABLE_SIZE;
}
void insert(struct HashTable* ht, int data) 
{
 int index = hashFunction(data);
 int attempt = 0;
 while (ht->table[index] != NULL) 
 {
 attempt++;
 index = quadraticProbe(index, attempt);
 if (attempt >= TABLE_SIZE) {
 printf("Hash Table is full. Cannot insert.\n");
 return;
 }
 }
 ht->table[index] = (struct HashEntry*)malloc(sizeof(struct HashEntry));
 ht->table[index]->key = data; // Using data itself as the key
 ht->table[index]->data = data;
 printf("Inserted data %d with key %d at index %d.\n", data, data, index);
}
int search(struct HashTable* ht, int data) 
{
 int index = hashFunction(data);
 int attempt = 0;
 while (ht->table[index] != NULL) 
 {
 if (ht->table[index]->data == data)
 return index;
 attempt++;
 index = quadraticProbe(index, attempt);
 if (attempt >= TABLE_SIZE || index == -1)
 break;
 }
 return -1;
}
void delete(struct HashTable* ht, int data) 
{
 int index = search(ht, data);
 if (index != -1) {
 free(ht->table[index]);
 ht->table[index] = NULL;
 printf("Deleted data %d.\n", data);
 } else {
 printf("Data not found. Cannot delete.\n");
 }
}
void display(struct HashTable* ht) 
{
int i;
 printf("Hash Table:\n");
 for (i = 0; i < TABLE_SIZE; i++) 
 {
 if (ht->table[i] != NULL)
 printf("Index %d: Key = %d, Data = %d\n", i, ht->table[i]->key, ht->table[i]->data);
 else
 printf("Index %d: Empty\n", i);
 }
}
void initializeHashTable(struct HashTable* ht) 
{
int i;
 for (i = 0; i < TABLE_SIZE; i++)
 ht->table[i] = NULL;
}
Q 2. Write a program to sort n randomly generated elements using Heapsort method.
#include<stdio.h>
#include<stdlib.h>
void display(int arr[],int n)
{
int i;
for(i=0; i<n; i++)
printf("%d\t", arr[i]);
}
void heapify(int a[], int top, int last)
{
int j, temp, key;
key = a[top];
j = 2*top+1;
if( (j<last) && (a[j] < a[j+1]) )
j = j+1;
if( (j<=last) && (key<a[j]) )
{
temp = a[top];
a[top] = a[j];
a[j] = temp;
heapify(a,j,last);
}
}void buildheap(int a[], int n)
{
int i;
for(i=n/2-1; i>=0; i--)
heapify(a,i,n-1);
}
void heapsort(int a[], int n)
{
int i, temp, top=0, last;
buildheap(a,n);
printf("Initial heap = ");
display(a,n);
for(last=n-1; last>=1; last--)
{
temp = a[top];
a[top] = a[last];
a[last] = temp;
printf("\n\nAfter iteration %d : ", n-last);
display(a,n);
heapify(a,top,last-1);
}
}
int main(){
int a[8] = {26,5,77,1,61,11,59,15};
heapsort(a,8);
return 0;
}
Slip18
Q1 write a c program that accepts the vertices and edges of a graph and stores it as an 
adjacency matrix . Display the adjacency matrix.
#include<stdio.h>
#include<malloc.h>
typedef struct node
{
int vertex;
struct node *next;
}NODE;
NODE *list[10];
void createmat(int m[10][10], int n)
{
int i,j;
char ans;
for(i=0;i<n;i++)
for(j=0;j<n;j++)
{
m[i][i]=0;
if(i!=j)
{
printf("Is there an edge between %d and %d (1/0) ",i+1,j+1);
scanf("%d", &m[i][j]);
}
}}
void dispmat(int m[10][10], int n)
{
int i,j;
printf("\nThe adjacency matrix is :\n");
for(i=0; i<n; i++)
{
for(j=0; j<n; j++)
printf("%5d", m[i][j]);
printf("\n");
}
}
void createlist(int m[10][10], int n)
{
int i,j;
struct node *temp, *newnode;
for(i=0; i<n; i++)
{
list[i]=NULL;
for(j=0; j<n; j++)
{
if(m[i][j]==1)
{
newnode=(NODE *)malloc(sizeof(NODE));newnode->next=NULL;
newnode->vertex=j+1;
if(list [i]==NULL)
list[i]=temp=newnode;
else
{
temp->next=newnode;
temp=newnode;
}
}
}
}
}
void displist(int n)
{
struct node *temp;
int i;
printf("\nThe adjacency list is:\n");
for(i=0; i<n; i++)
{
printf("\nv%d :", i+1);
temp=list[i];
while(temp)
{
printf("v%d ->", temp->vertex);temp=temp->next;
}
printf("NULL");
}
}
void main()
{
int m[10][10], n;
printf("\nEnter the number of vertices:");
scanf("%d", &n);
createmat(m,n);
dispmat(m,n);
createlist(m,n);
displist(n);
}
Q 2. Implement a Binary search tree (BST) library (btree.h) with operations – create, 
insert, preorder. Write a menu driven program that performs the above operations.
#include <stdio.h>
#include <stdlib.h>
typedef struct Node{
int data;
struct Node* left;
struct Node* right;
}Node;
Node* root = NULL;
Node* newNode(int d){
Node* newnode = (Node*)malloc(sizeof(Node));
newnode->data = d;
newnode->left = NULL;
newnode->right = NULL;
return newnode;
}
Node* buildBST(Node* root,int x){
if(root == NULL){
root = newNode(x);
return root;
}
else if(root->data > x){
root->left = buildBST(root->left,x);
}
else{
root->right = buildBST(root->right,x);
}
return root;
}
void solve(){
int data;
printf("Enter the data\n");
scanf("%d",&data);
while(data!=-1){
root = buildBST(root,data);
scanf("%d",&data);
}
}
int search(Node* root,int x){
if(root == NULL){
return 0;
}
else if(root->data == x){
return 1;
}
else if(root -> data > x){
return search(root->left,x);
}
else{
return search(root->right,x);
}
}
int searchBST(){
int data;
printf("Enter data to be searched\n");
scanf("%d",&data);
int ans;
ans = search(root,data);
if(ans == 1){
printf("data is present\n");
}
else{
printf("data is not present\n");
}
}
void inorder(Node* root){
if(root==NULL){
return;
}
inorder(root->left);
printf("%d ",root->data);
inorder(root->right);
}
void postorder(Node* root){
if(root==NULL){
return;
}
inorder(root->left);
inorder(root->right);
printf("%d ",root->data);
}
void preorder(Node* root){
if(root==NULL){
return;
}
printf("%d ",root->data);
inorder(root->left);
inorder(root->right);
}
int main(){
solve();
printf("\n");
printf("ROOT data = %d\n",root->data);
printf("Inorder Traversal : \n");
inorder(root);
printf("preorder Traversal : \n");
preorder(root);printf("\n");
printf("postorder Traversal : \n");
postorder(root);printf("\n");
printf("\n");
searchBST();
return 0;
}
OR
Q2. Write a C program for the Implementation of Prim’s Minimum spanning tree 
algorithm.
#include<stdio.h>
int a,b,u,v,n,i,j,ne=1;
int visited[10]= {0}
,min,mincost=0,cost[10][10];
void main() 
{
printf("\n Enter the number of nodes:");
scanf("%d",&n);
printf("Enter cost in form of adjacency matrix\n");
for (i=1;i<=n;i++)
for (j=1;j<=n;j++) {
scanf("%d",&cost[i][j]);
if(cost[i][j]==0)
cost[i][j]=999;
}
visited[1]=1;
printf("\n");
while(ne<n) 
{
for (i=1,min=999;i<=n;i++)
for (j=1;j<=n;j++)
if(cost[i][j]<min)
if(visited[i]!=0) 
{
min=cost[i][j];
a=u=i;
b=v=j;
}
if(visited[u]==0 || visited[v]==0) 
{
printf("\n Edge %d:(%d %d) cost:%d",ne++,a,b,min);
mincost+=min;
visited[b]=1;
}
cost[a][b]=cost[b][a]=999;
}
printf("\n Minimun cost=%d",mincost);
}
Slip19
Q 1. Implement a Binary search tree (BST) library (btree.h) with operations – create, 
insert, preorder. Write a menu driven program that performs the above operations.
#include <stdio.h>
#include <stdlib.h>
typedef struct Node{
int data;
struct Node* left;
struct Node* right;
}Node;
Node* root = NULL;
Node* newNode(int d){
Node* newnode = (Node*)malloc(sizeof(Node));
newnode->data = d;
newnode->left = NULL;
newnode->right = NULL;
return newnode;
}
Node* buildBST(Node* root,int x){
if(root == NULL){
root = newNode(x);
return root;
}
else if(root->data > x){
root->left = buildBST(root->left,x);
}
else{
root->right = buildBST(root->right,x);
}
return root;
}
void solve(){
int data;
printf("Enter the data\n");
scanf("%d",&data);
while(data!=-1){
root = buildBST(root,data);
scanf("%d",&data);
}
}
int search(Node* root,int x){
if(root == NULL){
return 0;
}
else if(root->data == x){
return 1;
}
else if(root -> data > x){
return search(root->left,x);
}
else{
return search(root->right,x);
}
}
int searchBST(){
int data;
printf("Enter data to be searched\n");
scanf("%d",&data);
int ans;
ans = search(root,data);
if(ans == 1){
printf("data is present\n");
}
else{
printf("data is not present\n");
}
}
void inorder(Node* root){
if(root==NULL){
return;
}
inorder(root->left);
printf("%d ",root->data);
inorder(root->right);
}
void postorder(Node* root){
if(root==NULL){
return;
}
inorder(root->left);
inorder(root->right);
printf("%d ",root->data);
}
void preorder(Node* root){
if(root==NULL){
return;
}
printf("%d ",root->data);
inorder(root->left);
inorder(root->right);
}
int main(){
solve();
printf("\n");
printf("ROOT data = %d\n",root->data);
printf("Inorder Traversal : \n");
inorder(root);
printf("preorder Traversal : \n");
preorder(root);printf("\n");
printf("postorder Traversal : \n");
postorder(root);printf("\n");
printf("\n");
searchBST();
return 0;
}
Q 2. Write a C program that accepts the vertices and edges of a graph. Create 
adjacency list and display the adjacency list.
#include<stdio.h>
#include<stdio.h>
#include<malloc.h>
typedef struct node
{
int vertex;
struct node *next;
}NODE;
NODE *list[10];
void createmat(int m[10][10], int n)
{
int i,j;
char ans;
for(i=0;i<n;i++)
for(j=0;j<n;j++)
{
m[i][i]=0;
if(i!=j)
{
printf("Is there an edge between %d and %d (1/0) ",i+1,j+1);
scanf("%d", &m[i][j]);
}
}}
void createlist(int m[10][10], int n)
{
int i,j;
struct node *temp, *newnode;
for(i=0; i<n; i++)
{
list[i]=NULL;
for(j=0; j<n; j++)
{
if(m[i][j]==1)
{
newnode=(NODE *)malloc(sizeof(NODE));newnode->next=NULL;
newnode->vertex=j+1;
if(list [i]==NULL)
list[i]=temp=newnode;
else
{
temp->next=newnode;
temp=newnode;
}
}
}
}
}
void displist(int n)
{
struct node *temp;
int i;
printf("\nThe adjacency list is:\n");
for(i=0; i<n; i++)
{
printf("\nv%d :", i+1);
temp=list[i];
while(temp)
{
printf("v%d ->", temp->vertex);temp=temp->next;
}
printf("NULL");
}
}
void main()
{
int m[10][10], n;
printf("\nEnter the number of vertices:");
scanf("%d", &n);
createmat(m,n);
createlist(m,n);
displist(n);
}
OR
Q 2. Write a C program that accepts the vertices and edges of a graph and store it as 
an adjacency matrix. Implement function to traverse the graph using Depth First 
Search (DFS) traversal
#include<stdio.h>
#define MAX 10
typedef struct
{
int data[MAX];
int top;
}STACK;
void initstack(STACK * ps)
{
ps->top=-1;
}
void push(STACK *ps, int num)
{
ps->data[++ps->top]=num;
}
int pop(STACK *ps)
{
return(ps->data[ps->top--]);
}
int isempty(STACK *ps)
{
return(ps->top==-1);
}
int isfull(STACK *ps){
return (ps->top==MAX-1);
}
void dfs(int m[10][10], int n)
{
int i, v, w, found;
int visited[10]={0};
STACK s;
initstack(&s);
v=0;
visited[v]=1;
push(&s,v);
printf("v%d" ,v+1);
while(1)
{
found=0;
for(w=0; w<n; w++)
{
if((m[v][w]==1)&&(visited[w]==0))
{
push(&s, w);
printf("v%d", w+1);
visited[w]=1;
v = w;
found = 1;break;
}
}
if(found == 0)// did not find an adjacent unvisited vertex
if(isempty(&s))
break;
else
v = pop(&s);
}
}
int recdfs(int m[10][10], int n, int v)
{
int w;
static int visited[10]={0};
visited[v]=1;
printf("v%d" ,v+1);
for(w=0; w<n; w++)
{
if( (m[v] [w]==1) && (visited[w]==0) )
recdfs(m,n,w);
}
}
int main()
{int m[10][10], n, i, j, w;
printf("\nHow many vertices:");
scanf("%d", &n);
for(i=0; i<n; i++)
for(j=0; j<n; j++)
{
if(i!=j)
{
printf("Is there edge between vertex %d and %d(1/0):", i+1, j+1);
scanf("%d", &m[i][j]);
}
}
printf("\nNon recursive depth first search is :");
dfs(m,n);
printf("\nRecursive depth first search is :");
recdfs(m,n,0);
}
Slip20
Q 1. Write a C program for the Implementation of Kruskal’s Minimum spanning tree 
algorithm.
#include <stdio.h>
#include <stdlib.h>
int i, j, k, a, b, u, v, n, ne = 1;
int min, mincost = 0, cost[9][9], parent[9];
int find(int);
int uni(int, int);
void main()
{
printf("Kruskal's algorithm in C\n");
printf("========================\n");
printf("Enter the no. of vertices:\n");
scanf("%d", &n);
printf("\nEnter the cost adjacency matrix:\n");
for (i = 1; i <= n; i++)
{
for (j = 1; j <= n; j++)
{
scanf("%d", &cost[i][j]);
if (cost[i][j] == 0)
cost[i][j] = 999;
}
}
printf("The edges of Minimum Cost Spanning Tree are\n");
while (ne < n)
{
for (i = 1, min = 999; i <= n; i++)
{
for (j = 1; j <= n; j++)
{
if (cost[i][j] < min)
{
min = cost[i][j];
a = u = i;
b = v = j;
}
}
}
u = find(u);
v = find(v);
if (uni(u, v))
{
printf("%d edge (%d,%d) =%d\n", ne++, a, b, min);
mincost += min;
}
cost[a][b] = cost[b][a] = 999;
}
printf("\nMinimum cost = %d\n", mincost);
}
int find(int i)
{
while (parent[i])
i = parent[i];
return i;
}
int uni(int i, int j)
{
if (i != j)
{
parent[j] = i;
return 1;
}
 
return 0;
}
Q 2. Write a program which uses binary search tree library and counts the total nodes 
and total leaf nodes in the tree. int countLeaf(T) – returns the total number of leaf 
nodes from BST
#include <stdio.h>
#include <stdlib.h>
typedef struct Node{
int data;
struct Node* left;
struct Node* right;
}Node;
Node* root = NULL;
int totalNodes = 0;
int totalleaf = 0;
Node* newNode(int d){
Node* newnode = (Node*)malloc(sizeof(Node));
newnode->data = d;
newnode->left = NULL;
newnode->right = NULL;
return newnode;
}
Node* buildBST(Node* root,int x){
if(root == NULL){
root = newNode(x);
return root;
}
else if(root->data > x){
root->left = buildBST(root->left,x);
}
else{
root->right = buildBST(root->right,x);
}
return root;
}
void solve(){
int data;
printf("Enter the data\n");
scanf("%d",&data);
while(data!=-1){
root = buildBST(root,data);
scanf("%d",&data);
}
}
void countNodes(Node* root){
if(root == NULL){
return;
}
if(root!=NULL){
totalNodes++;
}
countNodes(root->left);
countNodes(root->right);
}
void countleaf(Node* root){
if(root==NULL)
return;
if(root->left == NULL && root->right == NULL){
totalleaf++;
return;
}
countleaf(root->left);
countleaf(root->right);
}
int main(){
solve();
printf("\n");
countNodes(root);
countleaf(root);
printf("total Nodes = %d",totalNodes);
printf("Total leaf Nodes = %d",totalleaf);
return 0;
}
OR
Q 2. Write a C program that accepts the vertices and edges of a graph and store it as 
an adjacency matrix. Implement function to traverse the graph using Breadth First 
Search (BFS) traversal.
#include<stdio.h>
#define MAX 10
typedef struct
{
int data[MAX];
int front, rear;
}QUEUE;
/**functions****/
void initq(QUEUE *pq)
{
pq->front = pq->rear = -1;
}
void addq(QUEUE *pq, int num)
{
pq->rear++;
pq->data[pq->rear] = num;
}
int removeq(QUEUE *pq)
{
int num;
pq->front++;
num=pq->data[pq->front];
return(num);
}int isempty(QUEUE *pq)
{
return(pq->front == pq->rear);
}
int isfull(QUEUE *pq)
{
return(pq->rear==MAX-1);
}
void bfs(int m[10][10], int n)
{
int i, v, w;
int visited[10]={0};
QUEUE q;
initq(&q);
v=0;
visited[v]=1;
addq(&q,v);
while(!isempty(&q))
{
v=removeq(&q);
printf("v%d",v+1);
for(w=0; w<n; w++)
{
if((m[v][w]==1)&&(visited[w]==0)){
addq(&q, w);
visited[w]=1;
}
}
}
}
int main()
{
int m[10][10], n, i, j, w;
printf("\nHow many vertices:");
scanf("%d", &n);
for(i=0; i<n; i++)
for(j=0; j<n; j++)
{
if(i!=j)
{
printf("Is there edge between vertex %d and %d(1/0):", i+1,j+1);
scanf("%d", &m[i][j]);
}
}
printf("\nNon recursive breadth first search is :");
bfs(m,n);
}
Slip21
Q 1. Write a C program for the implementation of Dijkstra’s shortest path algorithm for 
findingshortest path from a given source vertex using adjacency cost matrix.
#include<stdio.h>
#define INFINITY 9999
#define MAX 10
void dijkstra(int G[MAX][MAX],int n,int startnode);
int main()
{
int G[MAX][MAX],i,j,n,u;
printf("Enter no. of vertices:");
scanf("%d",&n);
printf("\nEnter the adjacency matrix:\n");
for(i=0;i<n;i++)
for(j=0;j<n;j++)
scanf("%d",&G[i][j]);
printf("\nEnter the starting node:");
scanf("%d",&u);
dijkstra(G,n,u);
return 0;
}
void dijkstra(int G[MAX][MAX],int n,int startnode)
{
int cost[MAX][MAX],distance[MAX],pred[MAX];
int visited[MAX],count,mindistance,nextnode,i,j;
for(i=0;i<n;i++)
for(j=0;j<n;j++)
if(G[i][j]==0)
cost[i][j]=INFINITY;
else
cost[i][j]=G[i][j];
for(i=0;i<n;i++)
{
distance[i]=cost[startnode][i];
pred[i]=startnode;
visited[i]=0;
}
distance[startnode]=0;
visited[startnode]=1;
count=1;
while(count<n-1)
{
mindistance=INFINITY;
for(i=0;i<n;i++)
if(distance[i]<mindistance&&!visited[i])
{
mindistance=distance[i];
nextnode=i;
}
visited[nextnode]=1;
for(i=0;i<n;i++)
if(!visited[i])
if(mindistance+cost[nextnode][i]<distance[i])
{
distance[i]=mindistance+cost[nextnode][i];
pred[i]=nextnode;
}
count++;
}
for(i=0;i<n;i++)
if(i!=startnode)
{
printf("\nDistance of node%d=%d",i,distance[i]);
printf("\nPath=%d",i);
j=i;
do
{
j=pred[j];
printf("<-%d",j);
}
while(j!=startnode);
}
}
Q 2. Write a program which uses binary search tree library and counts the total nodes 
and total leaf nodes in the tree. int countLeaf(T) – returns the total number of leaf 
nodes from BST
#include <stdio.h>
#include <stdlib.h>
typedef struct Node{
int data;
struct Node* left;
struct Node* right;
}Node;
Node* root = NULL;
int totalNodes = 0;
int totalleaf = 0;
Node* newNode(int d){
Node* newnode = (Node*)malloc(sizeof(Node));
newnode->data = d;
newnode->left = NULL;
newnode->right = NULL;
return newnode;
}
Node* buildBST(Node* root,int x){
if(root == NULL){
root = newNode(x);
return root;
}
else if(root->data > x){
root->left = buildBST(root->left,x);
}
else{
root->right = buildBST(root->right,x);
}
return root;
}
void solve(){
int data;
printf("Enter the data\n");
scanf("%d",&data);
while(data!=-1){
root = buildBST(root,data);
scanf("%d",&data);
}
}
void countNodes(Node* root){
if(root == NULL){
return;
}
if(root!=NULL){
totalNodes++;
}
countNodes(root->left);
countNodes(root->right);
}
void countleaf(Node* root){
if(root==NULL)
return;
if(root->left == NULL && root->right == NULL){
totalleaf++;
return;
}
countleaf(root->left);
countleaf(root->right);
}
int main(){
solve();
printf("\n");
countNodes(root);
countleaf(root);
printf("total Nodes = %d",totalNodes);
printf("Total leaf Nodes = %d",totalleaf);
return 0;
}
OR
Q2. Write a C program for the Implementation of Prim’s Minimum spanning tree 
algorithm.
#include<stdio.h>
int a,b,u,v,n,i,j,ne=1;
int visited[10]= {0}
,min,mincost=0,cost[10][10];
void main() 
{
printf("\n Enter the number of nodes:");
scanf("%d",&n);
printf("Enter cost in form of adjacency matrix\n");
for (i=1;i<=n;i++)
for (j=1;j<=n;j++) {
scanf("%d",&cost[i][j]);
if(cost[i][j]==0)
cost[i][j]=999;
}
visited[1]=1;
printf("\n");
while(ne<n) 
{
for (i=1,min=999;i<=n;i++)
for (j=1;j<=n;j++)
if(cost[i][j]<min)
if(visited[i]!=0) 
{
min=cost[i][j];
a=u=i;
b=v=j;
}
if(visited[u]==0 || visited[v]==0) 
{
printf("\n Edge %d:(%d %d) cost:%d",ne++,a,b,min);
mincost+=min;
visited[b]=1;
}
cost[a][b]=cost[b][a]=999;
}
printf("\n Minimun cost=%d",mincost);
}
Slip22
Q 1. Write a C program that accepts the vertices and edges of a graph. Create 
adjacency list and display the adjacency list.
#include<stdio.h>
#include<stdio.h>
#include<malloc.h>
typedef struct node
{
int vertex;
struct node *next;
}NODE;
NODE *list[10];
void createmat(int m[10][10], int n)
{
int i,j;
char ans;
for(i=0;i<n;i++)
for(j=0;j<n;j++)
{
m[i][i]=0;
if(i!=j)
{
printf("Is there an edge between %d and %d (1/0) ",i+1,j+1);
scanf("%d", &m[i][j]);
}
}}
void createlist(int m[10][10], int n)
{
int i,j;
struct node *temp, *newnode;
for(i=0; i<n; i++)
{
list[i]=NULL;
for(j=0; j<n; j++)
{
if(m[i][j]==1)
{
newnode=(NODE *)malloc(sizeof(NODE));newnode->next=NULL;
newnode->vertex=j+1;
if(list [i]==NULL)
list[i]=temp=newnode;
else
{
temp->next=newnode;
temp=newnode;
}
}
}
}
}
void displist(int n)
{
struct node *temp;
int i;
printf("\nThe adjacency list is:\n");
for(i=0; i<n; i++)
{
printf("\nv%d :", i+1);
temp=list[i];
while(temp)
{
printf("v%d ->", temp->vertex);temp=temp->next;
}
printf("NULL");
}
}
void main()
{
int m[10][10], n;
printf("\nEnter the number of vertices:");
scanf("%d", &n);
createmat(m,n);
createlist(m,n);
displist(n);
}
Q 2. Implement a Binary search tree (BST) library (btree.h) with operations – create, 
insert, preorder. Write a menu driven program that performs the above operations.
#include <stdio.h>
#include <stdlib.h>
typedef struct Node{
int data;
struct Node* left;
struct Node* right;
}Node;
Node* root = NULL;
Node* newNode(int d){
Node* newnode = (Node*)malloc(sizeof(Node));
newnode->data = d;
newnode->left = NULL;
newnode->right = NULL;
return newnode;
}
Node* buildBST(Node* root,int x){
if(root == NULL){
root = newNode(x);
return root;
}
else if(root->data > x){
root->left = buildBST(root->left,x);
}
else{
root->right = buildBST(root->right,x);
}
return root;
}
void solve(){
int data;
printf("Enter the data\n");
scanf("%d",&data);
while(data!=-1){
root = buildBST(root,data);
scanf("%d",&data);
}
}
int search(Node* root,int x){
if(root == NULL){
return 0;
}
else if(root->data == x){
return 1;
}
else if(root -> data > x){
return search(root->left,x);
}
else{
return search(root->right,x);
}
}
int searchBST(){
int data;
printf("Enter data to be searched\n");
scanf("%d",&data);
int ans;
ans = search(root,data);
if(ans == 1){
printf("data is present\n");
}
else{
printf("data is not present\n");
}
}
void inorder(Node* root){
if(root==NULL){
return;
}
inorder(root->left);
printf("%d ",root->data);
inorder(root->right);
}
void postorder(Node* root){
if(root==NULL){
return;
}
inorder(root->left);
inorder(root->right);
printf("%d ",root->data);
}
void preorder(Node* root){
if(root==NULL){
return;
}
printf("%d ",root->data);
inorder(root->left);
inorder(root->right);
}
int main(){
solve();
printf("\n");
printf("ROOT data = %d\n",root->data);
printf("Inorder Traversal : \n");
inorder(root);
printf("preorder Traversal : \n");
preorder(root);printf("\n");
printf("postorder Traversal : \n");
postorder(root);printf("\n");
printf("\n");
searchBST();
return 0;
}
OR
Q 2. Write a C program that accepts the vertices and edges of a graph and store it as 
an adjacency matrix. Implement function to traverse the graph using Depth First 
Search (DFS) traversal
#include<stdio.h>
#define MAX 10
typedef struct
{
int data[MAX];
int top;
}STACK;
void initstack(STACK * ps)
{
ps->top=-1;
}
void push(STACK *ps, int num)
{
ps->data[++ps->top]=num;
}
int pop(STACK *ps)
{
return(ps->data[ps->top--]);
}
int isempty(STACK *ps)
{
return(ps->top==-1);
}
int isfull(STACK *ps){
return (ps->top==MAX-1);
}
void dfs(int m[10][10], int n)
{
int i, v, w, found;
int visited[10]={0};
STACK s;
initstack(&s);
v=0;
visited[v]=1;
push(&s,v);
printf("v%d" ,v+1);
while(1)
{
found=0;
for(w=0; w<n; w++)
{
if((m[v][w]==1)&&(visited[w]==0))
{
push(&s, w);
printf("v%d", w+1);
visited[w]=1;
v = w;
found = 1;break;
}
}
if(found == 0)// did not find an adjacent unvisited vertex
if(isempty(&s))
break;
else
v = pop(&s);
}
}
int recdfs(int m[10][10], int n, int v)
{
int w;
static int visited[10]={0};
visited[v]=1;
printf("v%d" ,v+1);
for(w=0; w<n; w++)
{
if( (m[v] [w]==1) && (visited[w]==0) )
recdfs(m,n,w);
}
}
int main()
{int m[10][10], n, i, j, w;
printf("\nHow many vertices:");
scanf("%d", &n);
for(i=0; i<n; i++)
for(j=0; j<n; j++)
{
if(i!=j)
{
printf("Is there edge between vertex %d and %d(1/0):", i+1, j+1);
scanf("%d", &m[i][j]);
}
}
printf("\nNon recursive depth first search is :");
dfs(m,n);
printf("\nRecursive depth first search is :");
recdfs(m,n,0);
}
Slip23
Q1. Write a C program for the Implementation of Prim’s Minimum spanning tree 
algorithm.
#include<stdio.h>
int a,b,u,v,n,i,j,ne=1;
int visited[10]= {0}
,min,mincost=0,cost[10][10];
void main() 
{
printf("\n Enter the number of nodes:");
scanf("%d",&n);
printf("Enter cost in form of adjacency matrix\n");
for (i=1;i<=n;i++)
for (j=1;j<=n;j++) {
scanf("%d",&cost[i][j]);
if(cost[i][j]==0)
cost[i][j]=999;
}
visited[1]=1;
printf("\n");
while(ne<n) 
{
for (i=1,min=999;i<=n;i++)
for (j=1;j<=n;j++)
if(cost[i][j]<min)
if(visited[i]!=0) 
{
min=cost[i][j];
a=u=i;
b=v=j;
}
if(visited[u]==0 || visited[v]==0) 
{
printf("\n Edge %d:(%d %d) cost:%d",ne++,a,b,min);
mincost+=min;
visited[b]=1;
}
cost[a][b]=cost[b][a]=999;
}
printf("\n Minimun cost=%d",mincost);
}
Q2. write a c program that accepts the vertices and edges of a graph and stores it as 
an adjacency matrix . Display the adjacency matrix.
#include<stdio.h>
#include<malloc.h>
typedef struct node
{
int vertex;
struct node *next;
}NODE;
NODE *list[10];
void createmat(int m[10][10], int n)
{
int i,j;
char ans;
for(i=0;i<n;i++)
for(j=0;j<n;j++)
{
m[i][i]=0;
if(i!=j)
{
printf("Is there an edge between %d and %d (1/0) ",i+1,j+1);
scanf("%d", &m[i][j]);
}
}}
void dispmat(int m[10][10], int n)
{
int i,j;
printf("\nThe adjacency matrix is :\n");
for(i=0; i<n; i++)
{
for(j=0; j<n; j++)
printf("%5d", m[i][j]);
printf("\n");
}
}
void createlist(int m[10][10], int n)
{
int i,j;
struct node *temp, *newnode;
for(i=0; i<n; i++)
{
list[i]=NULL;
for(j=0; j<n; j++)
{
if(m[i][j]==1)
{
newnode=(NODE *)malloc(sizeof(NODE));newnode->next=NULL;
newnode->vertex=j+1;
if(list [i]==NULL)
list[i]=temp=newnode;
else
{
temp->next=newnode;
temp=newnode;
}
}
}
}
}
void displist(int n)
{
struct node *temp;
int i;
printf("\nThe adjacency list is:\n");
for(i=0; i<n; i++)
{
printf("\nv%d :", i+1);
temp=list[i];
while(temp)
{
printf("v%d ->", temp->vertex);temp=temp->next;
}
printf("NULL");
}
}
void main()
{
int m[10][10], n;
printf("\nEnter the number of vertices:");
scanf("%d", &n);
createmat(m,n);
dispmat(m,n);
createlist(m,n);
displist(n);
}
OR
Q 2. Write a C program for the implementation of Floyd Warshall’s algorithm for finding 
all pairs shortest path using adjacency cost matrix.
#include <stdio.h>
#define V 4
#define INF 99999
void printSolution(int dist[][V]);
void floydWarshall(int dist[][V]) {
int i, j, k;
 for (k = 0; k < V; k++) {
 for (i = 0; i < V; i++) {
 for (j = 0; j < V; j++) {
 if (dist[i][k] + dist[k][j] < dist[i][j])
 dist[i][j] = dist[i][k] + dist[k][j];
 }
 }
 }
 printSolution(dist);
}
void printSolution(int dist[][V]) {
 printf("The following matrix shows the shortest distances between every pair of 
vertices:\n");
 for (int i = 0; i < V; i++) {
 for (int j = 0; j < V; j++) {
 if (dist[i][j] == INF)
 printf("%7s", "INF");
 else
 printf("%7d", dist[i][j]);
 }
 printf("\n");
 }
}
int main() {
 int graph[V][V] = { {0, 5, INF, 10},
 {INF, 0, 3, INF},
 {INF, INF, 0, 1},
 {INF, INF, INF, 0} };
 floydWarshall(graph);
 return 0;
}
Slip24
Q 1. Write a program to sort n randomly generated elements using Heapsort method.
#include<stdio.h>
#include<stdlib.h>
void display(int arr[],int n)
{
int i;
for(i=0; i<n; i++)
printf("%d\t", arr[i]);
}
void heapify(int a[], int top, int last)
{
int j, temp, key;
key = a[top];
j = 2*top+1;
if( (j<last) && (a[j] < a[j+1]) )
j = j+1;
if( (j<=last) && (key<a[j]) )
{
temp = a[top];
a[top] = a[j];
a[j] = temp;
heapify(a,j,last);
}
}void buildheap(int a[], int n)
{
int i;
for(i=n/2-1; i>=0; i--)
heapify(a,i,n-1);
}
void heapsort(int a[], int n)
{
int i, temp, top=0, last;
buildheap(a,n);
printf("Initial heap = ");
display(a,n);
for(last=n-1; last>=1; last--)
{
temp = a[top];
a[top] = a[last];
a[last] = temp;
printf("\n\nAfter iteration %d : ", n-last);
display(a,n);
heapify(a,top,last-1);
}
}
int main(){
int a[8] = {26,5,77,1,61,11,59,15};
heapsort(a,8);
return 0;
}
Q2. Write a C program for the Implementation of Prim’s Minimum spanning tree 
algorithm.
#include<stdio.h>
int a,b,u,v,n,i,j,ne=1;
int visited[10]= {0}
,min,mincost=0,cost[10][10];
void main() 
{
printf("\n Enter the number of nodes:");
scanf("%d",&n);
printf("Enter cost in form of adjacency matrix\n");
for (i=1;i<=n;i++)
for (j=1;j<=n;j++) {
scanf("%d",&cost[i][j]);
if(cost[i][j]==0)
cost[i][j]=999;
}
visited[1]=1;
printf("\n");
while(ne<n) 
{
for (i=1,min=999;i<=n;i++)
for (j=1;j<=n;j++)
if(cost[i][j]<min)
if(visited[i]!=0) 
{
min=cost[i][j];
a=u=i;
b=v=j;
}
if(visited[u]==0 || visited[v]==0) 
{
printf("\n Edge %d:(%d %d) cost:%d",ne++,a,b,min);
mincost+=min;
visited[b]=1;
}
cost[a][b]=cost[b][a]=999;
}
printf("\n Minimun cost=%d",mincost);
}
Slip25
Q 1. Write a C program for the implementation of Floyd Warshall’s algorithm for finding 
all pairs shortest path using adjacency cost matrix.
#include <stdio.h>
#define V 4
#define INF 99999
void printSolution(int dist[][V]);
void floydWarshall(int dist[][V]) {
int i, j, k;
 for (k = 0; k < V; k++) {
 for (i = 0; i < V; i++) {
 for (j = 0; j < V; j++) {
 if (dist[i][k] + dist[k][j] < dist[i][j])
 dist[i][j] = dist[i][k] + dist[k][j];
 }
 }
 }
 printSolution(dist);
}
void printSolution(int dist[][V]) {
 printf("The following matrix shows the shortest distances between every pair of 
vertices:\n");
 for (int i = 0; i < V; i++) {
 for (int j = 0; j < V; j++) {
 if (dist[i][j] == INF)
 printf("%7s", "INF");
 else
 printf("%7d", dist[i][j]);
 }
 printf("\n");
 }
}
int main() {
 int graph[V][V] = { {0, 5, INF, 10},
 {INF, 0, 3, INF},
 {INF, INF, 0, 1},
 {INF, INF, INF, 0} };
 floydWarshall(graph);
 return 0;
}
Q 2. Write a program to sort n randomly generated elements using Heapsort method.
#include<stdio.h>
#include<stdlib.h>
void display(int arr[],int n)
{
int i;
for(i=0; i<n; i++)
printf("%d\t", arr[i]);
}
void heapify(int a[], int top, int last)
{
int j, temp, key;
key = a[top];
j = 2*top+1;
if( (j<last) && (a[j] < a[j+1]) )
j = j+1;
if( (j<=last) && (key<a[j]) )
{
temp = a[top];
a[top] = a[j];
a[j] = temp;
heapify(a,j,last);
}
}void buildheap(int a[], int n)
{
int i;
for(i=n/2-1; i>=0; i--)
heapify(a,i,n-1);
}
void heapsort(int a[], int n)
{
int i, temp, top=0, last;
buildheap(a,n);
printf("Initial heap = ");
display(a,n);
for(last=n-1; last>=1; last--)
{
temp = a[top];
a[top] = a[last];
a[last] = temp;
printf("\n\nAfter iteration %d : ", n-last);
display(a,n);
heapify(a,top,last-1);
}
}
int main(){
int a[8] = {26,5,77,1,61,11,59,15};
heapsort(a,8);
return 0;
}
